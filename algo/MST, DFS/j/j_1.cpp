/*
no dont look
                                      ▓▓▓▓▓▓  ▓▓▓▓▓▓                                
                                      ▓▓  ░░▓▓▓▓  ▓▓▓▓▓▓                            
                                ▓▓▓▓▓▓▓▓░░  ░░▓▓░░░░▓▓▓▓  ▓▓                        
                              ▒▒▓▓░░  ▓▓░░░░░░░░░░░░▓▓░░░░▓▓                        
                                  ▒▒░░  ░░░░░░░░░░░░░░░░▓▓▓▓▒▒                      
                                  ▓▓░░░░░░░░░░░░░░░░░░░░▓▓░░▓▓                      
                ██████████    ▒▒▓▓░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓                      
            ██████      ██████    ▓▓▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒▒▒▒▒▓▓▓▓                      
          ████              ████████▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒  ▒▒▓▓                        
        ████                  ██████░░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                        
                          ██████████░░  ░░░░░░██░░░░░░████                          
                    ██████████    ██░░░░░░░░░░▒▒░░░░░░▒▒██                          
              ██████████          ██░░░░░░░░░░░░░░░░░░░░██                          
        ██████████                  ████░░░░░░░░░░░░░░░░██                          
      ██████                          ████░░░░░░▒▒▒▒░░██                            
    ████                              ██▓▓██░░░░░░░░██                              
  ████                          ████████▓▓▓▓████████                                
  ██                          ████▓▓▓▓▓▓████████▓▓██████                            
  ██                        ████▓▓▓▓▓▓▓▓▓▓██████▓▓██▓▓▓▓██                          
                          ▓▓████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓▓▓                        
                        ████████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓██                        
                      ██▓▓▓▓▓▓▓▓████████████████▓▓██████▓▓██                        
                      ██▓▓██▓▓▓▓████▒▒░░░░  ░░░░▓▓██▒▒██▓▓██                        
                    ██▓▓▓▓██████████▒▒  ░░░░    ▓▓██▒▒██▓▓████                      
                    ██▓▓▓▓▓▓████  ██▒▒░░    ░░░░▓▓██▒▒▒▒██████                      
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░      ▓▓██▒▒▒▒██▓▓██                      
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░░░░░░░░░▓▓██▒▒██▓▓██                      
                ██▓▓▓▓████▓▓██    ████▒▒░░    ░░░░▓▓██▒▒██▓▓▓▓██                    
                ██▓▓██░░░░██        ████████▓▓▓▓▓▓▓▓████████▓▓▓▓████                
                  ██░░░░████        ████████████████████████▓▓████░░████            
                ██░░░░░░░░██        ██▒▒░░░░░░░░░░░░░░░░████▓▓██░░░░░░░░██          
                ██░░░░░░░░░░██      ██░░    ░░░░░░░░░░░░░░░░████░░░░░░░░██          
                ██░░░░░░░░░░██      ██▒▒░░░░    ░░░░██░░░░░░████░░░░░░██            
                ██░░░░░░░░██      ██▒▒  ▒▒▒▒▒▒░░░░░░██░░░░░░░░████████              
                  ████████        ██████    ▒▒▒▒████░░████░░░░██                    
                                  ██    ████▒▒██  ████▒▒▒▒▒▒▒▒░░██                  
                                ██░░░░░░  ▒▒▒▒██    ██▒▒▒▒▒▒▒▒░░░░██                
                                ██░░░░░░▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██                
                              ██░░░░░░▒▒▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██                
                            ██░░░░░░░░▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██              
                            ██░░░░░░▒▒▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██              
                          ██░░░░░░▒▒▒▒▒▒██              ██▒▒▒▒▒▒░░░░██              
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██              
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██              
                          ██░░▒▒▒▒▒▒██                    ████████████              
                        ████████████                        ████████                
                        ██▓▓▓▓████                          ██▓▓▓▓██                
                      ████████████                        ██▓▓██████████            
                    ██▓▓▓▓▓▓▓▓██                          ██▓▓▓▓▓▓▓▓▓▓▓▓████        
                  ██▓▓▓▓▓▓▓▓▓▓██                          ██████▓▓▓▓▓▓░░░░░░██      
                ██▓▓░░░░░░░░████                                ██████████████      
                ██████████████                                                 
 */

// #pragma comment(linker, "/STACK:10485760")

#include <array>
#include <vector>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <fstream>
#include <functional>
#include <memory>
#include <set>
#include <map>
#include <cstdint>

#ifdef _DEBUG
auto cin = std::stringstream(R"delim(
4 4
1 2 1
2 3 2
3 4 5
4 1 4
)delim");
using std::cout;
#else
using std::cin;
using std::cout;
// auto cin = std::ifstream("minonpath.in");
// auto cout = std::ofstream("minonpath.out");
#endif

using uint = std::uint32_t;

using size_type = std::uint32_t;

using weight_t = std::int32_t;

using graph_t = std::vector<std::vector<size_type>>;

bool IsCyclic(const graph_t &graph)
{
	std::vector<char> visited(graph.size(), 0);
	std::function<bool(size_type)> dfs = [&](size_type c) -> bool {
		if (visited[c])
			return visited[c] % 2; // 1 -> true, 2 -> false
		visited[c] = 1;
		for (const auto &i : graph[c])
		{
			if (dfs(i))
				return true;
		}
		visited[c] = 2;
		return false;
	};
	for (size_type i = 1; i < graph.size(); i++)
		if (dfs(i))
			return true;
	return false;
}

std::vector<size_type> Toposort(const graph_t &graph)
{
	std::vector<size_type> ans;
	ans.reserve(graph.size());
	{
		std::vector<bool> visited(graph.size(), false);
		std::function<void(size_type)> dfs = [&](size_type c) {
			if (visited[c])
				return;
			visited[c] = true;
			for (const auto &i : graph[c])
				dfs(i);
			ans.emplace_back(c);
		};
		for (size_type i = 1; i < graph.size(); i++)
			dfs(i);
	}
	return ans;
}

template<typename T>
std::pair<T, T> make_ordered_pair(const T &l, const T &r)
{
	if (l <= r)
		return {l, r};
	else
		return {r, l};
}

/*
template<typename T, typename Y>
bool operator<(const std::pair<T, Y> &a, const std::pair<T, Y> &b)
{
	if (a.first < b.first)
		return true;
	if (a.first == b.first && a.second < b.second)
		return true;
	return false;
}
*/

std::vector<std::pair<size_type, size_type>> GetBridges(const graph_t &graph)
{
	std::vector<std::pair<size_type, size_type>> ans;

	size_type curtime = 0;

	std::vector<size_type> entert(graph.size());
	std::vector<size_type> metric(graph.size());
	std::vector<bool> visited(graph.size(), false);

	std::function<void(size_type, size_type)> dfs = [&](size_type cur, size_type from) {
		visited[cur] = true;
		entert[cur] = curtime;
		metric[cur] = curtime++;
		for (const auto &to : graph[cur])
		{
			if (to == from)
				continue;
			if (visited[to])
				metric[cur] = std::min(metric[cur], entert[to]);
			else
			{
				dfs(to, cur);
				metric[cur] = std::min(metric[cur], metric[to]);
				if (metric[to] > entert[cur])
					ans.emplace_back(cur, to);
			}
		}
	};
	for (size_type i = 1; i < graph.size(); i++)
		if (!visited[i])
			dfs(i, -1);
	return ans;
}

class DSU
{
public:
	std::vector<size_type> parent;
	DSU(size_type size) : parent(size)
	{
		for (size_type i = 0; i < size; i++)
			parent[i] = i;
	}

	size_type Parent(size_type v)
	{
		if (parent[v] == v)
			return v;
		return parent[v] = Parent(parent[v]);
	}

	void Join(size_type l, size_type r)
	{
		size_type
			L = Parent(l),
			R = Parent(r);
		parent[parent[L]] = R;
	}
};

struct edge
{
	size_type
		u, v;
	weight_t
		w;
	edge(void) {}
	edge(size_type u, size_type v, weight_t w) : u(u), v(v), w(w) {}
};

template<typename T>
void Kruskal(size_type n, std::vector<edge> &edges, T callback)
{
	std::sort(edges.begin(), edges.end(), [](const auto &a, const auto &b) { return a.w < b.w; });
	DSU dsu(n + 1);
	for (const auto &e : edges)
	{
		if (dsu.Parent(e.u) != dsu.Parent(e.v))
		{
			dsu.Join(e.u, e.v);
			callback(e);
		}
	}
}

int main(void)
{
	constexpr bool directed = false;
  size_type n, m;
  cin >> n >> m;
#if 0
	graph_t graph(n + 1);
	for (size_type i = 0; i < m; i++)
	{
		size_type a, b;
		cin >> a >> b;
		graph[a].emplace_back(b);
		if constexpr (!directed)
			graph[b].emplace_back(a);
	}
#else
	std::vector<edge> edges;
	for (size_type i = 0; i < m; i++)
	{
		size_type a, b;
		weight_t w;
		cin >> a >> b >> w;
		edges.emplace_back(a, b, w);
	}
#endif
	std::int64_t ans = 0;
	Kruskal(n, edges, [&ans](const auto &a) { ans += a.w; });
	std::cout << ans << std::endl;
  return 0;
}