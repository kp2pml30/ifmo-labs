/*
no dont look
                                      ▓▓▓▓▓▓  ▓▓▓▓▓▓
                                      ▓▓  ░░▓▓▓▓  ▓▓▓▓▓▓
                                ▓▓▓▓▓▓▓▓░░  ░░▓▓░░░░▓▓▓▓  ▓▓
                              ▒▒▓▓░░  ▓▓░░░░░░░░░░░░▓▓░░░░▓▓
                                  ▒▒░░  ░░░░░░░░░░░░░░░░▓▓▓▓▒▒
                                  ▓▓░░░░░░░░░░░░░░░░░░░░▓▓░░▓▓
                ██████████    ▒▒▓▓░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓
            ██████      ██████    ▓▓▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒▒▒▒▒▓▓▓▓
          ████              ████████▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒  ▒▒▓▓
        ████                  ██████░░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
                          ██████████░░  ░░░░░░██░░░░░░████
                    ██████████    ██░░░░░░░░░░▒▒░░░░░░▒▒██
              ██████████          ██░░░░░░░░░░░░░░░░░░░░██
        ██████████                  ████░░░░░░░░░░░░░░░░██
      ██████                          ████░░░░░░▒▒▒▒░░██
    ████                              ██▓▓██░░░░░░░░██
  ████                          ████████▓▓▓▓████████
  ██                          ████▓▓▓▓▓▓████████▓▓██████
  ██                        ████▓▓▓▓▓▓▓▓▓▓██████▓▓██▓▓▓▓██
                          ▓▓████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓▓▓
                        ████████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓██
                      ██▓▓▓▓▓▓▓▓████████████████▓▓██████▓▓██
                      ██▓▓██▓▓▓▓████▒▒░░░░  ░░░░▓▓██▒▒██▓▓██
                    ██▓▓▓▓██████████▒▒  ░░░░    ▓▓██▒▒██▓▓████
                    ██▓▓▓▓▓▓████  ██▒▒░░    ░░░░▓▓██▒▒▒▒██████
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░      ▓▓██▒▒▒▒██▓▓██
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░░░░░░░░░▓▓██▒▒██▓▓██
                ██▓▓▓▓████▓▓██    ████▒▒░░    ░░░░▓▓██▒▒██▓▓▓▓██
                ██▓▓██░░░░██        ████████▓▓▓▓▓▓▓▓████████▓▓▓▓████
                  ██░░░░████        ████████████████████████▓▓████░░████
                ██░░░░░░░░██        ██▒▒░░░░░░░░░░░░░░░░████▓▓██░░░░░░░░██
                ██░░░░░░░░░░██      ██░░    ░░░░░░░░░░░░░░░░████░░░░░░░░██
                ██░░░░░░░░░░██      ██▒▒░░░░    ░░░░██░░░░░░████░░░░░░██
                ██░░░░░░░░██      ██▒▒  ▒▒▒▒▒▒░░░░░░██░░░░░░░░████████
                  ████████        ██████    ▒▒▒▒████░░████░░░░██
                                  ██    ████▒▒██  ████▒▒▒▒▒▒▒▒░░██
                                ██░░░░░░  ▒▒▒▒██    ██▒▒▒▒▒▒▒▒░░░░██
                                ██░░░░░░▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                              ██░░░░░░▒▒▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░░░▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░▒▒▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                          ██░░░░░░▒▒▒▒▒▒██              ██▒▒▒▒▒▒░░░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                          ██░░▒▒▒▒▒▒██                    ████████████
                        ████████████                        ████████
                        ██▓▓▓▓████                          ██▓▓▓▓██
                      ████████████                        ██▓▓██████████
                    ██▓▓▓▓▓▓▓▓██                          ██▓▓▓▓▓▓▓▓▓▓▓▓████
                  ██▓▓▓▓▓▓▓▓▓▓██                          ██████▓▓▓▓▓▓░░░░░░██
                ██▓▓░░░░░░░░████                                ██████████████
                ██████████████
 */

// algorithm from https://www.mlpack.org/papers/emst.pdf

#include <array>
#include <vector>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <cstdint>
#include <cmath>
#include <sstream>

#ifdef _DEBUG
auto cin = std::stringstream(R"delim(
2
0 0
1 1
)delim");
using std::cout;
#else

#if 1
using std::cin;
#else
auto cin = std::ifstream("input.txt");
#endif
using std::cout;
// auto cin = std::ifstream("minonpath.in");
// auto cout = std::ofstream("minonpath.out");
#endif

using uint = std::uint32_t;
using size_type = std::uint16_t;
using weight_t = float;

using Edge = std::array<size_type, 2>;

// using graph_t = std::vector<std::vector<size_type>>;

template<typename T>
T pow2(const T &a) noexcept
{
	return a * a;
}

using CoordT = int;
using Point = std::array<CoordT, 2>;

struct UPoint
{
	Point pt;
	size_type id;
};

std::int64_t Len2(Point a, Point b)
{
	return pow2(a[0] - b[0]) + pow2(a[1] - b[1]);
}

struct AABB
{
	Point min, max;
	AABB(void) {}
	AABB(Point min, Point max) : min(min), max(max) {}

	bool Contains(Point a)
	{
		return 1
			&& a[0] >= min[0]
			&& a[1] >= min[1]
			&& a[0] <= max[0]
			&& a[1] <= max[1]
			;
	}

	int Big(void) const
	{
		if (pow2(min[0] - max[0]) > pow2(min[1] - max[1]))
			return 0;
		return 1;
	}
};

std::int64_t Len2(AABB const& a, AABB const& b)
{
	std::int64_t ans = 0;
	for (size_type k = 0; k < 2; k++)
		if (std::int64_t d = std::max(a.min[k], b.min[k]) - std::min(a.max[k], b.max[k]);  d > 0)
			ans += d * d;
	return ans;
}

template<typename ForwardIt>
AABB GetAABB(ForwardIt f, ForwardIt l)
{
	if (f == l)
	{
		auto
			mi = std::numeric_limits<CoordT>::min(),
			ma = std::numeric_limits<CoordT>::max();
		return AABB({mi, mi}, {ma, ma});
	}
	Point
		mi = f->pt,
		ma = f->pt;
	++f;
	while (f != l)
	{
		mi[0] = std::min(mi[0], f->pt[0]);
		mi[1] = std::min(mi[1], f->pt[1]);

		ma[0] = std::max(ma[0], f->pt[0]);
		ma[1] = std::max(ma[1], f->pt[1]);
		++f;
	}
	return AABB(mi, ma);
}

class KDTree
{
public:
	struct Node
	{
		AABB aabb;
		size_type start;
		size_type size;
		bool leaf;

		Node(void)
			: start(0)
			, leaf(false)
			, size(0)
		{}
	};

	std::vector<UPoint> points;
	std::vector<Node> nodes;

	KDTree(std::vector<Point> const& pt, size_type max_height)
	{
		points.reserve(pt.size());
		for (auto & p : pt)
			points.push_back({p, (size_type)points.size()});
		nodes.resize(pt.size() * 4);
		Build(1, 0, (size_type)pt.size(), max_height);
	}

	void Build(size_type node_id, size_type start, size_type size, size_type remaining_height)
	{
		nodes[node_id].aabb = GetAABB(points.cbegin() + start, points.cbegin() + start + size);
		nodes[node_id].start = start;
		nodes[node_id].size = size;

		if (size == 1 || remaining_height == 0)
		{
			nodes[node_id].leaf = true;
			return;
		}

		auto biggest = nodes[node_id].aabb.Big();

		std::nth_element(points.begin() + start, points.begin() + start + size / 2, points.begin() + start + size,
			[&](auto const& a, auto const& b) { return a.pt[biggest] < b.pt[biggest]; });

		Build(node_id * 2, start, size / 2, remaining_height - 1);
		Build(node_id * 2 + 1, start + size / 2, (size + 1) / 2, remaining_height - 1);
	}
};

class DSU
{
public:
	std::vector<size_type> parent;
	std::vector<size_type> rank;
	DSU(size_type size) noexcept : parent(size), rank(size)
	{
		for (size_type i = 0; i < size; i++)
		{
			parent[i] = i;
			rank[i] = 0;
		}
	}

	size_type Parent(size_type v) noexcept
	{
		auto root = v;
		while (parent[root] != root)
			root = parent[root];
		while (parent[v] != v)
		{
			auto j = parent[v];
			parent[v] = root;
			v = j;
		}
		return root;
	}

	void Join(size_type l, size_type r) noexcept
	{
		const size_type
			L = Parent(l),
			R = Parent(r);
		if (rank[L] == rank[R])
			rank[L]++;
		if (rank[L] > rank[R])
			parent[R] = L;
		else
			parent[L] = R;
	}

	bool Same(size_type l, size_type r) noexcept
	{
		return Parent(l) == Parent(r);
	}
};

class EBuilder
{
public:
	std::vector<Edge> emst_edges;
	double emst_len = 0.0;

	size_type points_size;
	DSU dsu;
	KDTree kd;
	std::vector<bool> is_connected_by_operator;
	std::vector<std::int64_t> node_approx_d; // d from paper
	std::vector<std::pair<std::int64_t, Edge>> nearest_set;

	EBuilder(std::vector<Point> const& points) : points_size((size_type)points.size()), dsu((size_type)points.size()), kd(points, (size_type)(floor(log2(points_size))))
	{
		is_connected_by_operator.assign(kd.nodes.size(), false);
		Solve();
	}

	void Solve()
	{
		while (emst_edges.size() + 1 < points_size)
		{
			node_approx_d.assign(kd.nodes.size(), std::numeric_limits<std::int64_t>::max());
			nearest_set.assign(points_size, {std::numeric_limits<std::int64_t>::max(), Edge({0, 0})});

			CheckConnectedOperator(1);

			ComponentNeighbours(1, 1);

			for (size_type i = 0; i < points_size; i++)
			{
				if (i == dsu.Parent(i))
				{
					Edge e = nearest_set[i].second;
					if (!dsu.Same(e[0], e[1]))
					{
						dsu.Join(e[0], e[1]);
						emst_edges.push_back(e);
						emst_len += sqrt(nearest_set[i].first);
					}
				}
			}
		}
	}

	void ComponentNeighbours(size_type Q, size_type R, size_type depth = 0)
	{
		if (is_connected_by_operator[Q]
		   && is_connected_by_operator[R]
		   && dsu.Same((kd.points.begin() + kd.nodes[Q].start)->id,
		               (kd.points.begin() + kd.nodes[R].start)->id))
			return;
		if (Len2(kd.nodes[Q].aabb, kd.nodes[R].aabb) > node_approx_d[Q])
			return;
		if (kd.nodes[Q].leaf && kd.nodes[R].leaf)
		{
			node_approx_d[Q] = 0;
			for (auto i = kd.points.begin() + kd.nodes[Q].start; i != kd.points.begin() + kd.nodes[Q].start + kd.nodes[Q].size; i++)
			{
				for (auto j = kd.points.begin() + kd.nodes[R].start; j != kd.points.begin() + kd.nodes[R].start + kd.nodes[R].size; j++)
					if (!dsu.Same(i->id, j->id))
						if (auto dist = Len2(i->pt, j->pt);  dist < nearest_set[dsu.Parent(i->id)].first)
							nearest_set[dsu.Parent(i->id)] = {dist, {i->id, j->id}};
				node_approx_d[Q] = std::max(node_approx_d[Q], nearest_set[dsu.Parent(i->id)].first);
			}
			return;
		}
		size_type Qleft = Q * 2;
		size_type Qright = Qleft + 1;
		size_type Rleft = R * 2;
		size_type Rright = Rleft + 1;
		if (kd.nodes[1].leaf)
		{
			ComponentNeighbours(Q, Rleft, depth);
			ComponentNeighbours(Q, Rright, depth);
			return;
		}
		if (kd.nodes[R].leaf)
		{
			ComponentNeighbours(Qleft, R, depth);
			ComponentNeighbours(Qright, R, depth);
			node_approx_d[Q] = std::max(node_approx_d[Qleft], node_approx_d[Qright]);
			return;
		}
		ComponentNeighbours(Qleft, Rleft, depth + 1);
		ComponentNeighbours(Qleft, Rright, depth + 1);
		ComponentNeighbours(Qright, Rright, depth + 1);
		ComponentNeighbours(Qright, Rleft, depth + 1);
		node_approx_d[Q] = std::max(node_approx_d[Qleft], node_approx_d[Qright]);
	}

	// Q |><| R checker
	void CheckConnectedOperator(size_type cur)
	{
		if (is_connected_by_operator[cur])
			return;
		if (kd.nodes[cur].leaf)
		{
			bool fully_connected = true;
			for (auto it = kd.points.begin() + kd.nodes[cur].start
			    ; std::next(it) != kd.points.begin() + kd.nodes[cur].start + kd.nodes[cur].size
			    ; ++it)
				fully_connected &= dsu.Same(it->id, std::next(it)->id);
			is_connected_by_operator[cur] = fully_connected;
			return;
		}
		size_type left = cur * 2;
		size_type right = cur * 2 + 1;
		CheckConnectedOperator(left);
		CheckConnectedOperator(right);
		if (is_connected_by_operator[left] && is_connected_by_operator[right]
		   && dsu.Same((kd.points.begin() + kd.nodes[left].start)->id, (kd.points.begin() + kd.nodes[right].start)->id))
			is_connected_by_operator[cur] = true;
	}
};

int main(void)
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	size_type n;
	cin >> n;

	std::vector<Point> verts;
	verts.reserve(n);
	for (size_type i = 0; i < n; i++)
	{
		int a, b;
		cin >> a >> b;
		verts.push_back({a, b});
	}

	EBuilder builder(verts);

	builder.Solve();

	std::cout << builder.emst_len << std::endl;

	return 0;
}