/*
no dont look
																			▓▓▓▓▓▓  ▓▓▓▓▓▓
																			▓▓  ░░▓▓▓▓  ▓▓▓▓▓▓
																▓▓▓▓▓▓▓▓░░  ░░▓▓░░░░▓▓▓▓  ▓▓
															▒▒▓▓░░  ▓▓░░░░░░░░░░░░▓▓░░░░▓▓
																	▒▒░░  ░░░░░░░░░░░░░░░░▓▓▓▓▒▒
																	▓▓░░░░░░░░░░░░░░░░░░░░▓▓░░▓▓
								██████████    ▒▒▓▓░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓
						██████      ██████    ▓▓▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒▒▒▒▒▓▓▓▓
					████              ████████▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒  ▒▒▓▓
				████                  ██████░░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
													██████████░░  ░░░░░░██░░░░░░████
										██████████    ██░░░░░░░░░░▒▒░░░░░░▒▒██
							██████████          ██░░░░░░░░░░░░░░░░░░░░██
				██████████                  ████░░░░░░░░░░░░░░░░██
			██████                          ████░░░░░░▒▒▒▒░░██
		████                              ██▓▓██░░░░░░░░██
	████                          ████████▓▓▓▓████████
	██                          ████▓▓▓▓▓▓████████▓▓██████
	██                        ████▓▓▓▓▓▓▓▓▓▓██████▓▓██▓▓▓▓██
													▓▓████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓▓▓
												████████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓██
											██▓▓▓▓▓▓▓▓████████████████▓▓██████▓▓██
											██▓▓██▓▓▓▓████▒▒░░░░  ░░░░▓▓██▒▒██▓▓██
										██▓▓▓▓██████████▒▒  ░░░░    ▓▓██▒▒██▓▓████
										██▓▓▓▓▓▓████  ██▒▒░░    ░░░░▓▓██▒▒▒▒██████
									██▓▓▓▓▓▓▓▓██    ██▒▒░░░░      ▓▓██▒▒▒▒██▓▓██
									██▓▓▓▓▓▓▓▓██    ██▒▒░░░░░░░░░░░░▓▓██▒▒██▓▓██
								██▓▓▓▓████▓▓██    ████▒▒░░    ░░░░▓▓██▒▒██▓▓▓▓██
								██▓▓██░░░░██        ████████▓▓▓▓▓▓▓▓████████▓▓▓▓████
									██░░░░████        ████████████████████████▓▓████░░████
								██░░░░░░░░██        ██▒▒░░░░░░░░░░░░░░░░████▓▓██░░░░░░░░██
								██░░░░░░░░░░██      ██░░    ░░░░░░░░░░░░░░░░████░░░░░░░░██
								██░░░░░░░░░░██      ██▒▒░░░░    ░░░░██░░░░░░████░░░░░░██
								██░░░░░░░░██      ██▒▒  ▒▒▒▒▒▒░░░░░░██░░░░░░░░████████
									████████        ██████    ▒▒▒▒████░░████░░░░██
																	██    ████▒▒██  ████▒▒▒▒▒▒▒▒░░██
																██░░░░░░  ▒▒▒▒██    ██▒▒▒▒▒▒▒▒░░░░██
																██░░░░░░▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
															██░░░░░░▒▒▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
														██░░░░░░░░▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
														██░░░░░░▒▒▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
													██░░░░░░▒▒▒▒▒▒██              ██▒▒▒▒▒▒░░░░██
												██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
												██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
													██░░▒▒▒▒▒▒██                    ████████████
												████████████                        ████████
												██▓▓▓▓████                          ██▓▓▓▓██
											████████████                        ██▓▓██████████
										██▓▓▓▓▓▓▓▓██                          ██▓▓▓▓▓▓▓▓▓▓▓▓████
									██▓▓▓▓▓▓▓▓▓▓██                          ██████▓▓▓▓▓▓░░░░░░██
								██▓▓░░░░░░░░████                                ██████████████
								██████████████
 */

 // #pragma comment(linker, "/STACK:10485760")

#include <array>
#include <vector>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <fstream>
#include <functional>
#include <memory>
#include <set>
#include <unordered_map>
#include <map>
#include <cstdint>

#ifdef _DEBUG
auto cin = std::stringstream(R"delim(
5 6
1 2
2 3
3 1
1 4
4 5
5 1
)delim");
using std::cout;
#else
using std::cin;
using std::cout;
// auto cin = std::ifstream("minonpath.in");
// auto cout = std::ofstream("minonpath.out");
#endif

using uint = std::uint32_t;

using size_type = std::uint32_t;

using graph_t = std::vector<std::vector<std::pair<size_type, size_type>>>;

std::vector<size_type> GetCutPts(const graph_t &graph, size_type m)
{
	size_type curtime = 0;

	std::vector<size_type> entert(graph.size());
	std::vector<size_type> metric(graph.size());
	std::vector<bool> visited(graph.size(), false);

	// cut points
	std::function<void(size_type, size_type)> dfs = [&](size_type cur, size_type from) {
		visited[cur] = true;
		entert[cur] = curtime;
		metric[cur] = curtime++;
		size_t children = 0;
		for (const auto &to : graph[cur])
		{
			if (to.second == from)
				continue;
			if (visited[to.first])
				metric[cur] = std::min(metric[cur], entert[to.first]);
			else
			{
				dfs(to.first, to.second);
				children++;
				metric[cur] = std::min(metric[cur], metric[to.first]);
				// if (from != -1 && metric[to.first] >= entert[cur])
				// 	ans.emplace_back(cur);
			}
		}
		// if (from == -1 && children > 1)
		// 	ans.emplace_back(cur);
	};
	for (size_type i = 1; i < graph.size(); i++)
		if (!visited[i])
			dfs(i, -1);

	std::vector<size_type> ans(m);
	visited.assign(visited.size(), false);

	size_type curcol = 0;

	std::function<void(size_type, size_type, size_type)> mark = [&](size_type cur, size_type color, size_type edge) {
		visited[cur] = true;
		for (const auto &e : graph[cur])
		{
			if (e.second == edge)
				continue;
			if (visited[e.first])
			{
				if (entert[e.first] < entert[cur])
					ans[e.second] = color;
				continue;
			}
			if (metric[e.first] >= entert[cur])
			{
				// cut point
				size_type col = ++curcol;
				ans[e.second] = col;
				mark(e.first, col, e.second);
			}
			else
			{
				ans[e.second] = color;
				mark(e.first, color, e.second);
			}
		}
	};
	for (size_type i = 1; i < graph.size(); i++)
		if (!visited[i])
			mark(i, ++curcol, -1);
	return ans;
}

int main(void)
{
	size_type n, m;
	cin >> n >> m;
	graph_t graph(n + 1);

	for (size_type i = 0; i < m; i++)
	{
		size_type a, b;
		cin >> a >> b;
		graph[a].emplace_back(b, i);
		graph[b].emplace_back(a, i);
	}

	auto ans = GetCutPts(graph, m);

	size_type maxcol = 0;
	std::unordered_map<size_type, size_type> mapper;
	for (auto &a : ans)
	{
		auto &bind = mapper[a];
		if (bind == 0)
			bind = ++maxcol;
		a = bind;
	}

	std::cout << maxcol << std::endl;
	for (const auto &a : ans)
		std::cout << a << ' ';
	std::cout << std::endl;
	return 0;
}