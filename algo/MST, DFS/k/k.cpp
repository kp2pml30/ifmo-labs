/*
no dont look
                                      ▓▓▓▓▓▓  ▓▓▓▓▓▓
                                      ▓▓  ░░▓▓▓▓  ▓▓▓▓▓▓
                                ▓▓▓▓▓▓▓▓░░  ░░▓▓░░░░▓▓▓▓  ▓▓
                              ▒▒▓▓░░  ▓▓░░░░░░░░░░░░▓▓░░░░▓▓
                                  ▒▒░░  ░░░░░░░░░░░░░░░░▓▓▓▓▒▒
                                  ▓▓░░░░░░░░░░░░░░░░░░░░▓▓░░▓▓
                ██████████    ▒▒▓▓░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓
            ██████      ██████    ▓▓▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒▒▒▒▒▓▓▓▓
          ████              ████████▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒  ▒▒▓▓
        ████                  ██████░░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
                          ██████████░░  ░░░░░░██░░░░░░████
                    ██████████    ██░░░░░░░░░░▒▒░░░░░░▒▒██
              ██████████          ██░░░░░░░░░░░░░░░░░░░░██
        ██████████                  ████░░░░░░░░░░░░░░░░██
      ██████                          ████░░░░░░▒▒▒▒░░██
    ████                              ██▓▓██░░░░░░░░██
  ████                          ████████▓▓▓▓████████
  ██                          ████▓▓▓▓▓▓████████▓▓██████
  ██                        ████▓▓▓▓▓▓▓▓▓▓██████▓▓██▓▓▓▓██
                          ▓▓████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓▓▓
                        ████████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓██
                      ██▓▓▓▓▓▓▓▓████████████████▓▓██████▓▓██
                      ██▓▓██▓▓▓▓████▒▒░░░░  ░░░░▓▓██▒▒██▓▓██
                    ██▓▓▓▓██████████▒▒  ░░░░    ▓▓██▒▒██▓▓████
                    ██▓▓▓▓▓▓████  ██▒▒░░    ░░░░▓▓██▒▒▒▒██████
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░      ▓▓██▒▒▒▒██▓▓██
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░░░░░░░░░▓▓██▒▒██▓▓██
                ██▓▓▓▓████▓▓██    ████▒▒░░    ░░░░▓▓██▒▒██▓▓▓▓██
                ██▓▓██░░░░██        ████████▓▓▓▓▓▓▓▓████████▓▓▓▓████
                  ██░░░░████        ████████████████████████▓▓████░░████
                ██░░░░░░░░██        ██▒▒░░░░░░░░░░░░░░░░████▓▓██░░░░░░░░██
                ██░░░░░░░░░░██      ██░░    ░░░░░░░░░░░░░░░░████░░░░░░░░██
                ██░░░░░░░░░░██      ██▒▒░░░░    ░░░░██░░░░░░████░░░░░░██
                ██░░░░░░░░██      ██▒▒  ▒▒▒▒▒▒░░░░░░██░░░░░░░░████████
                  ████████        ██████    ▒▒▒▒████░░████░░░░██
                                  ██    ████▒▒██  ████▒▒▒▒▒▒▒▒░░██
                                ██░░░░░░  ▒▒▒▒██    ██▒▒▒▒▒▒▒▒░░░░██
                                ██░░░░░░▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                              ██░░░░░░▒▒▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░░░▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░▒▒▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                          ██░░░░░░▒▒▒▒▒▒██              ██▒▒▒▒▒▒░░░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                          ██░░▒▒▒▒▒▒██                    ████████████
                        ████████████                        ████████
                        ██▓▓▓▓████                          ██▓▓▓▓██
                      ████████████                        ██▓▓██████████
                    ██▓▓▓▓▓▓▓▓██                          ██▓▓▓▓▓▓▓▓▓▓▓▓████
                  ██▓▓▓▓▓▓▓▓▓▓██                          ██████▓▓▓▓▓▓░░░░░░██
                ██▓▓░░░░░░░░████                                ██████████████
                ██████████████
 */

#include <array>
#include <vector>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <fstream>
#include <functional>
#include <memory>
#include <set>
#include <map>
#include <cstdint>
#include <limits>
#include <numeric>

#ifdef _DEBUG
auto cin = std::stringstream(R"delim(
9 12
1 2 -80
1 3 15
4 5 23
5 6 -56
6 8 19
6 9 -28
9 7 20
2 4 -44
4 3 99
8 6 -18
7 8 -48
6 4 -85
)delim");
using std::cout;
#else
using std::cin;
using std::cout;
// auto cin = std::ifstream("avia.in");
// auto cout = std::ofstream("avia.out");
#endif
using uint = std::uint32_t;
using size_type = std::uint16_t; // 65'536
using weight_t = std::int32_t;

struct edge
{
	edge const* chained;
	weight_t w, wt;
	size_type f, t;
	edge() = default;
	edge(size_type f, size_type t, weight_t w, edge const* chained = nullptr) : f(f), t(t), w(w), wt(chained == nullptr ? w : chained->wt), chained(chained) {}

	edge & operator=(edge const&) = default;
};

static bool edgeptrcom(edge const* a, edge const* b) { return a->w < b->w; }

using graph_t = std::vector<std::vector<edge*>>;

/**
 * @return {count_of_components, {vertex => component}}
 */
std::pair<size_type, std::vector<size_type>> GetSCC(graph_t& reversed, graph_t& graph)
{
	std::vector<size_type> order;
	order.reserve(reversed.size());
	{
		std::vector<bool> visited(reversed.size());
		size_type t = 0;
		std::function<void(size_type)> dfs = [&](size_type cur) {
			if (visited[cur])
				return;
			visited[cur] = true;
			for (const auto &e : reversed[cur])
				dfs(e->f);
			// timeout[cur] = t++;
			order.push_back(cur);
		};
		for (size_type i = 0; i < graph.size(); i++)
			dfs(i);
	}

	std::vector<size_type> color(graph.size(), -1);
	size_type curcol = 0;
	{
		std::function<void(size_type)> dfs = [&](size_type cur) {
			if (color[cur] != (size_type)-1)
				return;
			color[cur] = curcol;
			for (const auto &e : graph[cur])
				dfs(e->t);
		};
		std::reverse(order.begin(), order.end());
		for (const auto &i : order)
			if (color[i] == (size_type)-1)
			{
				dfs(i);
				curcol++;
			}
	}
	return {curcol, color};
}

/**
 * @return vector of taken edges, that make diMST, same as in `reversed`
 */
std::vector<edge const*> DiMST(graph_t& reversed, size_type mst_root)
{
	std::vector<edge const*> ret;
	ret.reserve(reversed.size());

	size_type edges_count = 0;

	// new graphs to find scc
	graph_t
		new_min_g(reversed.size()),
		new_min_r(reversed.size());
	// get min edges
	std::vector<edge const*> min_edges;
	{
		min_edges.reserve(reversed.size());

		size_type iteration_no = 0;
		for (auto& v_edges : reversed)
		{
			edges_count += v_edges.size();
			if (iteration_no++ == mst_root)
				continue;
			if (v_edges.empty())
				throw "bad graph";
			edge *min = *std::min_element(v_edges.begin(), v_edges.end(), edgeptrcom);
			weight_t mw = min->w;
			for (auto& e : v_edges)
				e->w -= mw;
			min_edges.emplace_back(min);
			new_min_g[min->f].emplace_back(min);
			new_min_r[min->t].emplace_back(min);
		}
	}

#if 0
	{
		std::vector<bool> visited(reversed.size(), false);
		size_type vn = 1;
		visited[mst_root] = true;
		std::function<void(size_type)> dfs_build_mst_in_scc = [&](size_type cur) {
		};
	}
#endif

	auto [count_of_scc, scc] = GetSCC(new_min_r, new_min_g);
	if (count_of_scc == reversed.size())
		return min_edges; // done

	std::vector<std::vector<edge*>> edgs_in_same_scc(reversed.size());

	// make new reversed
	std::vector<edge> my_edges_storage;
	my_edges_storage.reserve(edges_count);
	graph_t scc_graph(count_of_scc);
	for (auto& v_edges : reversed)
	{
		for (auto& e : v_edges)
			if (scc[e->f] != scc[e->t])
			{
				my_edges_storage.emplace_back(scc[e->f], scc[e->t], e->w, e);
				scc_graph[scc[e->t]].emplace_back(&my_edges_storage.back());
			}
			else if (e->w == 0) // for dfs in 1 component
			{
				edgs_in_same_scc[e->f].emplace_back(e);
			}
	}

	std::vector<bool> visited(reversed.size(), false);
	std::function<void(size_type)> dfs_build_mst_in_scc = [&](size_type cur) {
		visited[cur] = true;
		for (auto const& e : edgs_in_same_scc[cur])
			if (!visited[e->t])
			{
				ret.emplace_back(e); // already points to edge from non-owning collection
				dfs_build_mst_in_scc(e->t);
			}
	};
	dfs_build_mst_in_scc(mst_root);

	auto scc_edges = DiMST(scc_graph, scc[mst_root]);
	for (auto const& edge : scc_edges)
	{
		// edge points to scc_graph, we own it, replace with chained
		ret.emplace_back(edge->chained);
		dfs_build_mst_in_scc(edge->chained->t);
	}

	return ret;
}

int main(void)
{
  size_type n, m;
  cin >> n >> m;

	std::vector<edge> all_edges;
	std::map<size_type, edge*> takenedges;

	all_edges.reserve(m);

	std::vector<std::vector<edge*>> reversed(n), graph(n);

	{
		std::map<std::pair<size_type, size_type>, edge*> was;
		for (size_type i = 0; i < m; i++)
		{
			size_type f, t;
			weight_t w;
			cin >> f >> t >> w;
			if (f == t)
				continue; // we should not add it
			if (t == 1)
				continue; // we should not add it
			f--;
			t--;
			if (auto iter = was.find({f, t}); iter != was.cend())
			{
				iter->second->w = iter->second->wt = std::min(w, iter->second->wt);
				continue;
			}
			all_edges.emplace_back(f, t, w);
			was.emplace(std::make_pair(f, t), &all_edges.back());
			reversed[t].emplace_back(&all_edges.back());
			graph[f].emplace_back(&all_edges.back());
		}
	}

	// check answer exists
	{
		std::vector<bool> visited(n, false);
		visited[0] = true;
		size_type vn = 1;
		std::function<void(size_type)> dfs = [&](size_type cur) {
			for (auto const& e : graph[cur])
			{
				if (!visited[e->t])
				{
					visited[e->t] = true;
					vn++;
					dfs(e->t);
				}
			}
		};
		dfs(0);
		if (vn != n)
		{
			cout << "NO" << std::endl;
			return 0;
		}
	}

	auto ans = DiMST(reversed, 0);

	cout
		<< "YES\n"
		<< std::accumulate(ans.begin(), ans.end(),
		                   (std::int64_t)0,
		                   [](std::int64_t b, edge const* a) { return (std::int64_t)a->wt + b; })
		<< std::endl;
	return 0;
}