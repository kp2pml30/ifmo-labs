/*
no dont look
                                      ▓▓▓▓▓▓  ▓▓▓▓▓▓
                                      ▓▓  ░░▓▓▓▓  ▓▓▓▓▓▓
                                ▓▓▓▓▓▓▓▓░░  ░░▓▓░░░░▓▓▓▓  ▓▓
                              ▒▒▓▓░░  ▓▓░░░░░░░░░░░░▓▓░░░░▓▓
                                  ▒▒░░  ░░░░░░░░░░░░░░░░▓▓▓▓▒▒
                                  ▓▓░░░░░░░░░░░░░░░░░░░░▓▓░░▓▓
                ██████████    ▒▒▓▓░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓
            ██████      ██████    ▓▓▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒▒▒▒▒▓▓▓▓
          ████              ████████▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒  ▒▒▓▓
        ████                  ██████░░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
                          ██████████░░  ░░░░░░██░░░░░░████
                    ██████████    ██░░░░░░░░░░▒▒░░░░░░▒▒██
              ██████████          ██░░░░░░░░░░░░░░░░░░░░██
        ██████████                  ████░░░░░░░░░░░░░░░░██
      ██████                          ████░░░░░░▒▒▒▒░░██
    ████                              ██▓▓██░░░░░░░░██
  ████                          ████████▓▓▓▓████████
  ██                          ████▓▓▓▓▓▓████████▓▓██████
  ██                        ████▓▓▓▓▓▓▓▓▓▓██████▓▓██▓▓▓▓██
                          ▓▓████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓▓▓
                        ████████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓██
                      ██▓▓▓▓▓▓▓▓████████████████▓▓██████▓▓██
                      ██▓▓██▓▓▓▓████▒▒░░░░  ░░░░▓▓██▒▒██▓▓██
                    ██▓▓▓▓██████████▒▒  ░░░░    ▓▓██▒▒██▓▓████
                    ██▓▓▓▓▓▓████  ██▒▒░░    ░░░░▓▓██▒▒▒▒██████
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░      ▓▓██▒▒▒▒██▓▓██
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░░░░░░░░░▓▓██▒▒██▓▓██
                ██▓▓▓▓████▓▓██    ████▒▒░░    ░░░░▓▓██▒▒██▓▓▓▓██
                ██▓▓██░░░░██        ████████▓▓▓▓▓▓▓▓████████▓▓▓▓████
                  ██░░░░████        ████████████████████████▓▓████░░████
                ██░░░░░░░░██        ██▒▒░░░░░░░░░░░░░░░░████▓▓██░░░░░░░░██
                ██░░░░░░░░░░██      ██░░    ░░░░░░░░░░░░░░░░████░░░░░░░░██
                ██░░░░░░░░░░██      ██▒▒░░░░    ░░░░██░░░░░░████░░░░░░██
                ██░░░░░░░░██      ██▒▒  ▒▒▒▒▒▒░░░░░░██░░░░░░░░████████
                  ████████        ██████    ▒▒▒▒████░░████░░░░██
                                  ██    ████▒▒██  ████▒▒▒▒▒▒▒▒░░██
                                ██░░░░░░  ▒▒▒▒██    ██▒▒▒▒▒▒▒▒░░░░██
                                ██░░░░░░▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                              ██░░░░░░▒▒▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░░░▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░▒▒▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                          ██░░░░░░▒▒▒▒▒▒██              ██▒▒▒▒▒▒░░░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                          ██░░▒▒▒▒▒▒██                    ████████████
                        ████████████                        ████████
                        ██▓▓▓▓████                          ██▓▓▓▓██
                      ████████████                        ██▓▓██████████
                    ██▓▓▓▓▓▓▓▓██                          ██▓▓▓▓▓▓▓▓▓▓▓▓████
                  ██▓▓▓▓▓▓▓▓▓▓██                          ██████▓▓▓▓▓▓░░░░░░██
                ██▓▓░░░░░░░░████                                ██████████████
                ██████████████
 */

// algorithm from https://www.mlpack.org/papers/emst.pdf

#include <array>
#include <vector>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <cstdint>
#include <cmath>
#include <sstream>
#include <map>

#ifdef _DEBUG
auto cin = std::stringstream(R"delim(
4 2
1 2 10
2 3 5
1 2 4
)delim");
using std::cout;
#else

#if 1
using std::cin;
#else
auto cin = std::ifstream("input.txt");
#endif
using std::cout;
// auto cin = std::ifstream("minonpath.in");
// auto cout = std::ofstream("minonpath.out");
#endif

using uint = std::uint32_t;
using size_type = std::uint32_t;
using weight_t = std::uint64_t;

constexpr weight_t maxw = std::numeric_limits<weight_t>::max() / 4;

struct edge
{
	size_type t;
	weight_t w;

	edge() = default;
	
	edge(size_type t, weight_t w) : t(t), w(w) {}
};

std::vector<weight_t> Dijkstra(std::vector<std::vector<edge>> const& graph, size_type s)
{
	size_type n = graph.size();
	std::multimap<weight_t, size_type> sorted;

	std::vector<weight_t> d(n, maxw);
	std::vector<decltype(sorted)::iterator> ind2iter(n);

	for (size_type i = 0; i < n; i++)
		if (i == s)
		{
			d[s] = 0;
			ind2iter[s] = sorted.emplace(0, s);
		}
		else
		{
			d[i] = maxw;
			ind2iter[i] = sorted.emplace(maxw, i);
		}

	std::vector<bool> visited(n, false);

	visited[s] = true;

	while (!sorted.empty())
	{
		edge from;
		{
			auto iter = sorted.begin();
			from = {iter->second, iter->first};
			sorted.erase(iter);
			ind2iter[from.t] = sorted.end();
		}
		ind2iter[from.t] = sorted.end();

		visited[from.t] = true;
		for (auto const& v : graph[from.t])
		{
			if (visited[v.t])
				continue;
			if (d[v.t] > from.w + v.w)
			{
				auto to = sorted.extract(ind2iter[v.t]);
				if (to.empty())
					throw "up";
				to.key() = d[v.t] = from.w + v.w;
				ind2iter[v.t] = sorted.insert(std::move(to));
			}
		}
	}
	return d;
}

template<typename T1, typename ...T>
auto minimum(T1 a, T... rest)
{
	if constexpr (sizeof...(T) == 0)
		return a;
	else
		return std::min(a, minimum(rest...));
}

int main(void)
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	size_type n, m;
	cin >> n >> m;

	std::vector<std::vector<edge>> graph(n);
	for (size_type i = 0; i < m; i++)
	{
		size_type f, t;
		weight_t w;
		cin >> f >> t >> w;
		f--;
		t--;
		graph[f].emplace_back(t, w);
		graph[t].emplace_back(f, w);
	}

	size_type a, b, c;
	cin >> a >> b >> c;
	a--;
	b--;
	c--;

	weight_t ab, ac;
	{
		auto v = Dijkstra(graph, a);
		ab = v[b];
		ac = v[c];
	}
	weight_t ba, bc;
	{
		auto v = Dijkstra(graph, b);
		ba = v[a];
		bc = v[c];
	}
	weight_t ca, cb;
	{
		auto v = Dijkstra(graph, c);
		ca = v[a];
		cb = v[b];
	}

	auto ans = minimum(
		ab + bc, ab + ba + ac, ac + cb, ac + ca + cb,
		ba + ac, ba + ab + bc, bc + ca, bc + cb + ba,
		ca + ab, ca + ac + cb, cb + ba, cb + bc + ca
	);

	if (ans >= maxw)
		cout << -1;
	else
		cout << ans;

	cout << std::endl;

	return 0;
}