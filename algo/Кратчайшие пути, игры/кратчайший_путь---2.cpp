/*
no dont look
                                      ▓▓▓▓▓▓  ▓▓▓▓▓▓
                                      ▓▓  ░░▓▓▓▓  ▓▓▓▓▓▓
                                ▓▓▓▓▓▓▓▓░░  ░░▓▓░░░░▓▓▓▓  ▓▓
                              ▒▒▓▓░░  ▓▓░░░░░░░░░░░░▓▓░░░░▓▓
                                  ▒▒░░  ░░░░░░░░░░░░░░░░▓▓▓▓▒▒
                                  ▓▓░░░░░░░░░░░░░░░░░░░░▓▓░░▓▓
                ██████████    ▒▒▓▓░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓
            ██████      ██████    ▓▓▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒▒▒▒▒▓▓▓▓
          ████              ████████▓▓▓▓▓▓▓▓▓▓▒▒    ▒▒  ▒▒▓▓
        ████                  ██████░░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
                          ██████████░░  ░░░░░░██░░░░░░████
                    ██████████    ██░░░░░░░░░░▒▒░░░░░░▒▒██
              ██████████          ██░░░░░░░░░░░░░░░░░░░░██
        ██████████                  ████░░░░░░░░░░░░░░░░██
      ██████                          ████░░░░░░▒▒▒▒░░██
    ████                              ██▓▓██░░░░░░░░██
  ████                          ████████▓▓▓▓████████
  ██                          ████▓▓▓▓▓▓████████▓▓██████
  ██                        ████▓▓▓▓▓▓▓▓▓▓██████▓▓██▓▓▓▓██
                          ▓▓████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓▓▓
                        ████████▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓██▓▓██▓▓██
                      ██▓▓▓▓▓▓▓▓████████████████▓▓██████▓▓██
                      ██▓▓██▓▓▓▓████▒▒░░░░  ░░░░▓▓██▒▒██▓▓██
                    ██▓▓▓▓██████████▒▒  ░░░░    ▓▓██▒▒██▓▓████
                    ██▓▓▓▓▓▓████  ██▒▒░░    ░░░░▓▓██▒▒▒▒██████
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░      ▓▓██▒▒▒▒██▓▓██
                  ██▓▓▓▓▓▓▓▓██    ██▒▒░░░░░░░░░░░░▓▓██▒▒██▓▓██
                ██▓▓▓▓████▓▓██    ████▒▒░░    ░░░░▓▓██▒▒██▓▓▓▓██
                ██▓▓██░░░░██        ████████▓▓▓▓▓▓▓▓████████▓▓▓▓████
                  ██░░░░████        ████████████████████████▓▓████░░████
                ██░░░░░░░░██        ██▒▒░░░░░░░░░░░░░░░░████▓▓██░░░░░░░░██
                ██░░░░░░░░░░██      ██░░    ░░░░░░░░░░░░░░░░████░░░░░░░░██
                ██░░░░░░░░░░██      ██▒▒░░░░    ░░░░██░░░░░░████░░░░░░██
                ██░░░░░░░░██      ██▒▒  ▒▒▒▒▒▒░░░░░░██░░░░░░░░████████
                  ████████        ██████    ▒▒▒▒████░░████░░░░██
                                  ██    ████▒▒██  ████▒▒▒▒▒▒▒▒░░██
                                ██░░░░░░  ▒▒▒▒██    ██▒▒▒▒▒▒▒▒░░░░██
                                ██░░░░░░▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                              ██░░░░░░▒▒▒▒▒▒██        ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░░░▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                            ██░░░░░░▒▒▒▒▒▒██            ██▒▒▒▒▒▒▒▒░░██
                          ██░░░░░░▒▒▒▒▒▒██              ██▒▒▒▒▒▒░░░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                        ██░░░░░░▒▒▒▒▒▒██                ██▒▒▒▒▒▒▒▒░░██
                          ██░░▒▒▒▒▒▒██                    ████████████
                        ████████████                        ████████
                        ██▓▓▓▓████                          ██▓▓▓▓██
                      ████████████                        ██▓▓██████████
                    ██▓▓▓▓▓▓▓▓██                          ██▓▓▓▓▓▓▓▓▓▓▓▓████
                  ██▓▓▓▓▓▓▓▓▓▓██                          ██████▓▓▓▓▓▓░░░░░░██
                ██▓▓░░░░░░░░████                                ██████████████
                ██████████████
 */

// algorithm from https://www.mlpack.org/papers/emst.pdf

#include <array>
#include <vector>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <cstdint>
#include <cmath>
#include <sstream>
#include <map>

#ifdef _DEBUG
auto cin = std::stringstream(R"delim(
4 5
1 2 1
1 3 5
2 4 8
3 4 1
2 3 3
)delim");
using std::cout;
#else

#if 1
using std::cin;
#else
auto cin = std::ifstream("input.txt");
#endif
using std::cout;
// auto cin = std::ifstream("minonpath.in");
// auto cout = std::ofstream("minonpath.out");
#endif

using uint = std::uint32_t;
using size_type = std::uint32_t;
using weight_t = std::int64_t;

struct edge
{
	size_type t;
	weight_t w;

	edge() = default;
	
	edge(size_type t, weight_t w) : t(t), w(w) {}
};

int main(void)
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	size_type n, m;
	cin >> n >> m;

	std::vector<std::vector<edge>> graph(n);
	for (size_type i = 0; i < m; i++)
	{
		size_type f, t;
		weight_t w;
		cin >> f >> t >> w;
		f--;
		t--;
		graph[f].emplace_back(t, w);
		graph[t].emplace_back(f, w);
	}

	constexpr weight_t maxw = std::numeric_limits<weight_t>::max() - 800'000;

	std::multimap<weight_t, size_type> sorted;

	std::vector<weight_t> d(n);
	std::vector<decltype(sorted)::iterator> ind2iter(n);

	for (size_type i = 1; i < n; i++)
	{
		d[i] = maxw;
		ind2iter[i] = sorted.emplace(maxw, i);
	}
	d[0] = 0;
	ind2iter[0] = sorted.emplace(0, 0);

	std::vector<bool> visited(n, false);

	while (!sorted.empty()) // (true)
	{
		edge from;
#if 1
		{
			auto iter = sorted.begin();
			from = {iter->second, iter->first};
			sorted.erase(iter);
			ind2iter[from.t] = sorted.end();
		}
		ind2iter[from.t] = sorted.end();
#else
		{
			int fr = -1;
			for (size_type i = 0; i < n; i++)
				if (!visited[i] && (fr == -1 || d[i] < d[fr]))
					fr = i;
			if (fr == -1)
				break;
			from.t = fr;
			from.w = d[fr];
	}
#endif
		visited[from.t] = true;
		for (auto const& v : graph[from.t])
		{
			if (visited[v.t])
				continue;
			if (d[v.t] > from.w + v.w)
			{
#if 1
				auto to = sorted.extract(ind2iter[v.t]);
				if (to.empty())
					return 0;
				to.key() = d[v.t] = from.w + v.w;
				ind2iter[v.t] = sorted.insert(std::move(to));
#else
				d[v.t] = from.w + v.w;
#endif
			}
		}
	}

	for (size_type i = 0; i < n; i++)
		cout << d[i] << ' ';
	cout << std::endl;

	return 0;
}