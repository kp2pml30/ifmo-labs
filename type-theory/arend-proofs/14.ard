\import Algebra.Domain.Euclidean
\import Data.Or
\import Function
\import Logic.Classical
\import Order.LinearOrder
\import Order.PartialOrder
\import Relation.Equivalence
\import Algebra.Monoid
\import Algebra.Ring
\import Arith.Int
\import Arith.Nat
\import Data.Bool
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Set \hiding (#)

\import tt13

\class Setoid (S : \Type)
  | \infix 4 ~ : S -> S -> \Prop
  | ~-reflexive {x : S} : x ~ x
  | ~-symmetric {x y : S} : x ~ y -> y ~ x
  | ~-transitive {x y z : S} : x ~ y -> y ~ z -> x ~ z
  \where {
    \use \coerce toQuotient (S : Setoid) : \Type => Quotient {S.S} (S.~)
    \func toQuotionEl {P : Setoid} (x : P.S) : Quotient {P.S} (P.~) => in~ x
  }

\instance ModSetoid (k : Nat) : Setoid Int
  | ~ (a : Int) (b : Int) =>
    \let
    | am => a IntEuclidean.mod suc k
    | bm => b IntEuclidean.mod suc k
    \in am = bm
  | ~-reflexive => idp
  | ~-symmetric => inv
  | ~-transitive => *>

\func task3Extend<=
  {b : Nat}
  {res : Bool}
  {f : Nat -> Bool}
  (proofLess : \Pi (a : Nat) -> a <= b -> f a = res)
  (proofCur : f (suc b) = res)
  -- : \Pi (a : Nat) -> a <= suc b -> f a = res =>
  (a : Nat)
  (a<=sb : a <= suc b)
  : f a = res =>
    \case LinearOrder.<=-dec a<=sb \with {
      | inl a<sb => \let | a<=b => <_suc_<= a<sb \in proofLess a a<=b
      | inr a=sb => pmap f a=sb *> proofCur
    }

\func task3Help
  (f : Nat -> Bool)
  (cur : Nat)
  : Or
    (\Sigma (z : Nat) (proofSat : f z = true) (proofMin : \Pi (b : Nat) -> f b = true -> (z NatSemiring.<= b)))
    (\Pi (b : Nat) -> b NatSemiring.<= cur -> f b = false)
  \elim cur
    | 0 =>
      \case f 0 \as f0, idp : f 0 = f0 \with {
      | false, f0=false => inr (\lam (b : Nat) (b<=0 : b NatSemiring.<= 0) =>
          -- f b = f 0
          pmap f (<=-antisymmetric b<=0 (zero<=_ {b})) *>
          -- f b = false
          f0=false)
      | true, f0=true => inl (0, f0=true, \lam (b : Nat) (eq : f b = true) => zero<=_ {b})
      }
    | suc c =>
      \case task3Help f c \with {
      | inl a => inl a
      | inr bad_<=c =>
        \case f (suc c) \as fsc, idp : f (suc c) = fsc \with {
        | false, fsc=false => inr (task3Extend<= bad_<=c fsc=false)
        | true, fsc=true => inl (suc c, fsc=true,
            \lam (b : Nat) (fb=true : f b = true) =>
              \case LinearOrder.dec<_<= b (suc c) \with {
              | inl b<sc => \let | fb=false => bad_<=c b (<_suc_<= b<sc) \in absurd $ true/=false $ inv fb=true *> fb=false
              | inr sc<=b => sc<=b
              })
        }
      }

\func task3Decidable
  (f : Nat -> Bool)
  (x : Nat)
  (nonEmpty : f x = true)
  : \Sigma (z : Nat) (proofSat : f z = true) (proofMin : \Pi (b : Nat) -> f b = true -> (z NatSemiring.<= b)) =>
    \case task3Help f x \with {
    | inl res => res
    | inr bad<=x => absurd $ true/=false $ inv nonEmpty *> bad<=x x <=-reflexive
    }

\func task3DecidableExists
  (f : Nat -> Bool)
  (nonEmpty : ∃ (x : Nat) (f x = true))
  : ∃ (z : Nat) (proofSat : f z = true) (proofMin : \Pi (b : Nat) -> f b = true -> (z NatSemiring.<= b))
  => TruncP.map nonEmpty (\lam (x : Nat, fx=true) => task3Decidable f x fx=true)

\func task3Problems =>
  \Pi
    (R : Nat -> \Prop)
    (x : Nat)
    (xSat : R x) ->
  \Sigma
    (min : Nat)
    (minSat : R min)
    (isMin : \Pi (any : Nat) -> R any -> (min NatSemiring.<= any))

\func task3ExcludedMiddle
  {phi : \Prop}
  (problems : task3Problems)
  : Dec phi
  =>
    \let
    | R (x : Nat) => (x = 1) || phi
    | (min, minSat, isMin) => problems R 1 (byLeft idp)
    \in \case min \as m, idp : m = min \with {
    | 0, -0=min => yes $
          ||.rec
              (Path.inProp {phi})
              (\lam (x=1 : min = 1) => suc/=0 $ inv (-0=min *> x=1))
              id
              minSat
    | suc s, ss=min => no (\lam (phi' : phi) =>
      \let
        | aaa =>
          <=-antisymmetric
            (zero<=_ {suc s})
            (transport (\lam (x : Nat) => x NatSemiring.<= 0) (inv ss=min) (isMin 0 $ byRight phi'))
        \in suc/=0 $ inv aaa)
    }

\func task3ProblemsExist =>
  \Pi
    (R : Nat -> \Prop) ->
      ∃ (x : Nat) (xSat : R x) ->
      ∃ (min : Nat)
          (minSat : R min)
          (isMin : \Pi (any : Nat) -> R any -> (min NatSemiring.<= any))

\func task3ExcludedMiddleExist
  {phi : \Prop}
  (problems : task3ProblemsExist)
  : Dec phi
  =>
    \let
    | R (x : Nat) => (x = 1) || phi
    \in
    \case problems R (inP (1, byLeft idp)) \with {
      | inP (min, minSat, isMin) =>
        \case min \as m, idp : m = min \with {
        | 0, -0=min => yes $
          ||.rec
              (Path.inProp {phi})
              (\lam (x=1 : min = 1) => suc/=0 $ inv (-0=min *> x=1))
              id
              minSat
        | suc s, ss=min => no (\lam (phi' : phi) =>
          \let
          | aaa =>
            <=-antisymmetric
              (zero<=_ {suc s})
              (transport (\lam (x : Nat) => x NatSemiring.<= 0) (inv ss=min) (isMin 0 $ byRight phi'))
          \in suc/=0 $ inv aaa)
        }
    }

{- task2 by nh5 -}
\func equiv (A B : \Prop) => \Sigma (A -> B) (B -> A)

\func setoidFromEquiv {S : \Set} {P : \Set} (E : P -> S -> \Prop) : Setoid S \cowith
  | ~ (x y : S) => \Pi (p : P) -> equiv (E p x) (E p y)
  | ~-reflexive => \lam p => (id, id)
  | ~-symmetric {x y : S} (x~y : x ~ y) => \lam p => ((x~y p).2, (x~y p).1)
  | ~-transitive {x y z : S} (x~y : x ~ y) (y~z : y ~ z) => \lam p => ((y~z p).1 o (x~y p).1, (x~y p).2 o (y~z p).2)

\func setoidFromS {I : \Set} {S : \Set} (A : I -> S -> \Prop) => setoidFromEquiv A
\func setoidFromI {I : \Set} {S : \Set} (A : I -> S -> \Prop) => setoidFromEquiv (\lam x i => A i x)

\func quotFromS {I : \Set} {S : \Set} (A : I -> S -> \Prop) => Setoid.toQuotient (setoidFromS A)
\func quotFromI {I : \Set} {S : \Set} (A : I -> S -> \Prop) => Setoid.toQuotient (setoidFromI A)

\func recA {I : \Set} {S : \Set} (A : I -> S -> \Prop) (i : I) (s : quotFromS A) : \Prop
\elim s
  | in~ a => A i a
  | ~-equiv x y r i1 => propExt (r i).1 (r i).2 @ i1

\func recI {I : \Set} {S : \Set} (A : I -> S -> \Prop) (i : quotFromI A) (s : S) : \Prop
\elim i
  | in~ a => A a s
  | ~-equiv x y r i1 => propExt (r s).1 (r s).2 @ i1

\func recAI {I : \Set} {S : \Set} (A : I -> S -> \Prop) (i : quotFromI A) (x : quotFromS A) : \Prop
\elim i, x
  | in~ i, in~ x => A i x
  | in~ i, ~-equiv x x' r i1 => propExt (r i).1 (r i).2 @ i1
  | ~-equiv i i' r i1, in~ x => propExt (r x).1 (r x).2 @ i1

\func recAIin=>recI {I : \Set} {S : \Set} (A : I -> S -> \Prop) (i : quotFromI A) (x : S) (p : recAI A i (in~ x)) : recI A i x \elim i, x
  | in~ a, x => p

\func notEmpty {I : \Set} {S : \Set} (A : I -> S -> \Prop) (i : quotFromI A) => ∃ (x : quotFromS A) (recAI A i x)

{- Task 2 -}
\class SetoidChoice \extends LEM
  | setoidChoice :
  \Pi (I : \Set) (S : \Set) (A : I -> S -> \Prop) (not_empty : \Pi (i : quotFromI A) -> notEmpty A i) ->
      ∃ (f : \Pi (i : quotFromI A) -> S) (\Pi (i : quotFromI A) -> recI A i (f i))
  | lem (P : \Prop) =>
    \case setoidChoice Bool Bool (A P) (not_empty P) \with {
      | inP (f, p) => \case f (in~ false) \as f0, idp : f (in~ false) = f0, f (in~ true) \as f1, idp : f (in~ true) = f1 \with {
        | false, p0, false, p1 => \case p (in~ true) \with {
          | byLeft a => contradiction
          | byRight b => yes b
        }
        | false, p0, true, p1 => no (\lam (pyes : P) => true/=false (inv $ inv p0 *> f~false=f~true P f pyes *> p1))
        | true, p0, false, p1 => no (\lam (pyes : P) => true/=false (inv p0 *> f~false=f~true P f pyes *> p1))
        | true, p0, true, p1 => \case p (in~ false) \with {
          | byLeft a => contradiction
          | byRight b => yes b
        }
      }
    }
  \where {
    \func f~false=f~true (P : \Prop) (f : \Pi (i : quotFromI (A P)) -> Bool) (pyes : P) : f (in~ false) = f (in~ true) =>
      pmap f (path (~-equiv false true (\lam _ => (\lam _ => byRight pyes, \lam _ => byRight pyes) : \Pi (x : Bool) -> equiv (A P false x) (A P true x))))

    \func A (P : \Prop) (i : Bool) (s : Bool) : \Prop \elim i
      | false => (s = false) || P
      | true => (s = true) || P

    \func not_empty (P : \Prop) (i : quotFromI (A P)) : notEmpty (A P) i \elim i
      | in~ a => \case \elim a \with {
        | false => inP (in~ false, byLeft idp)
        | true => inP (in~ true, byLeft idp)
      }
  }
{- end of task2 by nh5 -}

\func elementOfSet {S : \Set} (P : S -> \Prop) : \Set => \Sigma (a : S) (p : P a)

-- quotFromI A === Quotient (~)

\class Task8 \extends AC, SetoidChoice
  | setoidChoice (I : \Set) (S : \Set) (A : I -> S -> \Prop) (not_empty : \Pi (i : quotFromI A) -> notEmpty A i) =>
    {-
    : ∃ (f : \Pi (i : quotFromI A) -> S)
        (\Pi (i : quotFromI A) -> recI A i (f i))
     -}
    \let
      | choice
        : ∃ (\Pi (i : quotFromI A) -> elementOfSet (recI A i))
        => axiomOfChoice
            (\lam (i : quotFromI A) => elementOfSet (recI A i))
            (\lam i =>
              TruncP.rec
                TruncP.levelProp
                (not_empty i)
                (\lam (x, px) =>  aaaa A not_empty i x px))
    \in
      TruncP.map
        choice
        (\lam (f : \Pi (x : quotFromI A) -> elementOfSet (recI A x)) =>
            (\lam i => (f i).1,
             \lam i => (f i).2))
  \where {
    \func aaaa
      {I : \Set}
      {S : \Set}
      (A : I -> S -> \Prop)
      (not_empty : \Pi (i : quotFromI A) -> notEmpty A i)
      (i : quotFromI A)
      (x : Setoid.toQuotient (setoidFromS A))
      (px : recAI A i x)
      : ∃ (elementOfSet $ recI A i)
    \elim x
      | in~ x' => inP (x', recAIin=>recI A i x' px)
  }