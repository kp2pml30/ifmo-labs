#import "typst-prooftree/prooftree.typ": *
#set heading(numbering: "1.1")
#set page(numbering: "1")

#counter(heading).update(4)

= HW 5

== Расширить $R_T(t)$
=== для $T := "Nat"$
- $R_("Nat")(0)$
- $R_("Nat")("succ" t)$, если $R_("Nat")(t)$
- $"iszero"$ и $"pred"$ аналогичны (у нас на лекции, правда, succ вроде был значением, тогда и условие ему не нужно, внутри всегда значение)

=== для $T := T_1 + T_2$
- $R_(T_1 + T_2)("inl" t_1)$, если $R_(T_1)(t_1)$
- $R_(T_1 + T_2)("inr" t_2)$, если $R_(T_2)(t_2)$
- $R_(A)("case" x "of" "inl" t_1 => a_1 ; "inr" t_2 => a_2)$, если $R_(T_1 + T_2)$, и выполнены одновременно все:
	- $R_(T_1 + T_2)(x)$
	- $R_(T_1 -> A)(lambda t_1. a_1)$
	- $R_(T_2 -> A)(lambda t_2. a_2)$

=== для let

Eсли это производная форма --- очевидно, иначе

$R_(A)("let" x: T = s space $in$ space v)$ титт
- $R_(T)(s)$
- $s -> x'$ (в нормальной форме)
- $R_(A)([x |-> x'] v)$

== Расширить доказательство леммы о сохранении свойства $R_T$

Лемма которую мы расширяем: Если $t : T$ и $t -> t'$, то $R_(T)(t)$ титт, когда $R_(T)(t')$.

=== для $T := "Nat"$

- $R_(T)(0)$ очевидно ($0$ это значение, $0 -> 0$)
- $R_(T)("succ" t)$ когда дано $R_(T)(t)$. очевидно из определения того, как вычисляется succ, т.е. $t -> t'$ титт когда $"succ" t -> "succ" t'$

=== для $T := T_1 + T_2$
Конструкторы --- очевидно / аналогично "succ" (редуцируется под ними и навешивается их сверху)

набор условий для $R$ для let соответствует строгой схеме его вычисления

== Расширьте доказательство леммы о нормализации открытых термов

Лемма которую мы расширяем:
#prooftree(
	axiom(label: $X_1$, $x_1 : T_1, ..., x_n : T_n tack.r t : T$),
	axiom(label: $X_2$, $v_1, ..., v_n" замкнутые значения типов "T_1, ..., T_n$),
	axiom(label: $X_3$, $R_(T_i)(v_i)$),
	rule(n: 3, $R_(T)([ x_1 |-> v_1, ..., x_n |-> v_n] space t)$)
)

// Вспомним, что $R_(T_1 -> T_2)(t)$ титт $t$ завершается и для всякого $s$ такого, что $R_(T_1)(s)$, выполняется $R_(T_2)(t space s)$

//рассмотрим паттерн матчинг. Нам дано:
//
//- $R_(T_1 + T_2)(x)$
//- $R_(T_1 -> A)(lambda t_1. a_1)$
//- $R_(T_2 -> A)(lambda t_2. a_2)$

//как мы получили $R_(T_1 + T_2)(x)$? через конструкторы, значит верно как минимум одно из:
//- $R_(T_1)(t_1)$
//	+ $R_(T_1 -> A)(lambda t_1. a_1)$
//	+ $R_(A)((lambda t_1. a_1) space t_1)$
//- $R_(T_2)(t_2)$
//	+ $R_(T_2 -> A)(lambda t_2. a_2)$
//	+ $R_(A)((lambda t_2. a_2) space t_2)$

//Значит, и матчинг завершается

- T-Zero очевидно (переменных то нет)
- T-Succ, T-Pred, T-IsZero, T-Inl, T-Inr делегируют доказательство своему операнду (очевидно по индукции в подвыражения), т.к. оставляют значения значениями и делают это в каком-то смысле за $O(1)$
- T-Case на самом деле вроде как очевиден
  #prooftree(
		axiom($Gamma tack.r x: T_1 + T_2$),
		axiom($Gamma, t_1 : T_1 tack.r a_1 : A$),
		axiom($Gamma, t_2 : T_2 tack.r a_2 : A$),
		rule(n: 3, $Gamma tack.r "case" x "of" "inl" t_1 => a_1 ; "inr" t_2 => a_2 : A$),
	)
	тогда $x := "inl"(v_(t_1)) | "inr"(v_(t_2))$ и все завершится
- T-Let если это производная форма --- очевидно
	- иначе несложно увидеть соответствие данному мной определению: $R_(A)("let" x: T = s space $in$ space v)$ титт
		+ $R_(T)(s)$ матчится на $X_3$
		+ $s -> x'$ (в нормальной форме) матчится на $X_2$
		+ $R_(A)([x |-> x'] v)$ матчится на вывод
