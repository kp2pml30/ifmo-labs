-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Gen.ParSyntax
  ( happyError
  , myLexer
  , pProgram
  , pListStellaIdent
  , pLanguageDecl
  , pExtension
  , pListExtensionName
  , pListExtension
  , pDecl
  , pListDecl
  , pLocalDecl
  , pListLocalDecl
  , pAnnotation
  , pListAnnotation
  , pParamDecl
  , pListParamDecl
  , pReturnType
  , pThrowType
  , pType9
  , pListType9
  , pMatchCase
  , pListMatchCase
  , pOptionalTyping
  , pPatternData
  , pExprData
  , pPattern
  , pListPattern
  , pLabelledPattern
  , pListLabelledPattern
  , pBinding
  , pListBinding
  , pExpr
  , pListExpr
  , pExpr1
  , pPatternBinding
  , pListPatternBinding
  , pExpr2
  , pListExpr2
  , pExpr3
  , pExpr4
  , pExpr5
  , pExpr6
  , pExpr7
  , pType
  , pType1
  , pType2
  , pType3
  , pListType
  , pVariantFieldType
  , pListVariantFieldType
  , pRecordFieldType
  , pListRecordFieldType
  , pTyping
  ) where

import Prelude

import qualified Gen.AbsSyntax
import Gen.LexSyntax

}

%name pProgram Program
%name pListStellaIdent ListStellaIdent
%name pLanguageDecl LanguageDecl
%name pExtension Extension
%name pListExtensionName ListExtensionName
%name pListExtension ListExtension
%name pDecl Decl
%name pListDecl ListDecl
%name pLocalDecl LocalDecl
%name pListLocalDecl ListLocalDecl
%name pAnnotation Annotation
%name pListAnnotation ListAnnotation
%name pParamDecl ParamDecl
%name pListParamDecl ListParamDecl
%name pReturnType ReturnType
%name pThrowType ThrowType
%name pType9 Type9
%name pListType9 ListType9
%name pMatchCase MatchCase
%name pListMatchCase ListMatchCase
%name pOptionalTyping OptionalTyping
%name pPatternData PatternData
%name pExprData ExprData
%name pPattern Pattern
%name pListPattern ListPattern
%name pLabelledPattern LabelledPattern
%name pListLabelledPattern ListLabelledPattern
%name pBinding Binding
%name pListBinding ListBinding
%name pExpr Expr
%name pListExpr ListExpr
%name pExpr1 Expr1
%name pPatternBinding PatternBinding
%name pListPatternBinding ListPatternBinding
%name pExpr2 Expr2
%name pListExpr2 ListExpr2
%name pExpr3 Expr3
%name pExpr4 Expr4
%name pExpr5 Expr5
%name pExpr6 Expr6
%name pExpr7 Expr7
%name pType Type
%name pType1 Type1
%name pType2 Type2
%name pType3 Type3
%name pListType ListType
%name pVariantFieldType VariantFieldType
%name pListVariantFieldType ListVariantFieldType
%name pRecordFieldType RecordFieldType
%name pListRecordFieldType ListRecordFieldType
%name pTyping Typing
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='            { PT _ (TS _ 1)             }
  '&'             { PT _ (TS _ 2)             }
  '('             { PT _ (TS _ 3)             }
  ')'             { PT _ (TS _ 4)             }
  '*'             { PT _ (TS _ 5)             }
  '+'             { PT _ (TS _ 6)             }
  ','             { PT _ (TS _ 7)             }
  '-'             { PT _ (TS _ 8)             }
  '->'            { PT _ (TS _ 9)             }
  '.'             { PT _ (TS _ 10)            }
  '/'             { PT _ (TS _ 11)            }
  ':'             { PT _ (TS _ 12)            }
  ':='            { PT _ (TS _ 13)            }
  ';'             { PT _ (TS _ 14)            }
  '<'             { PT _ (TS _ 15)            }
  '<='            { PT _ (TS _ 16)            }
  '<|'            { PT _ (TS _ 17)            }
  '='             { PT _ (TS _ 18)            }
  '=='            { PT _ (TS _ 19)            }
  '=>'            { PT _ (TS _ 20)            }
  '>'             { PT _ (TS _ 21)            }
  '>='            { PT _ (TS _ 22)            }
  'Bool'          { PT _ (TS _ 23)            }
  'Bot'           { PT _ (TS _ 24)            }
  'List::head'    { PT _ (TS _ 25)            }
  'List::isempty' { PT _ (TS _ 26)            }
  'List::tail'    { PT _ (TS _ 27)            }
  'Nat'           { PT _ (TS _ 28)            }
  'Nat::iszero'   { PT _ (TS _ 29)            }
  'Nat::pred'     { PT _ (TS _ 30)            }
  'Nat::rec'      { PT _ (TS _ 31)            }
  'Top'           { PT _ (TS _ 32)            }
  'Unit'          { PT _ (TS _ 33)            }
  '['             { PT _ (TS _ 34)            }
  ']'             { PT _ (TS _ 35)            }
  'and'           { PT _ (TS _ 36)            }
  'as'            { PT _ (TS _ 37)            }
  'cast'          { PT _ (TS _ 38)            }
  'catch'         { PT _ (TS _ 39)            }
  'cons'          { PT _ (TS _ 40)            }
  'core'          { PT _ (TS _ 41)            }
  'else'          { PT _ (TS _ 42)            }
  'exception'     { PT _ (TS _ 43)            }
  'extend'        { PT _ (TS _ 44)            }
  'false'         { PT _ (TS _ 45)            }
  'fix'           { PT _ (TS _ 46)            }
  'fn'            { PT _ (TS _ 47)            }
  'fold'          { PT _ (TS _ 48)            }
  'forall'        { PT _ (TS _ 49)            }
  'generic'       { PT _ (TS _ 50)            }
  'if'            { PT _ (TS _ 51)            }
  'in'            { PT _ (TS _ 52)            }
  'inl'           { PT _ (TS _ 53)            }
  'inline'        { PT _ (TS _ 54)            }
  'inr'           { PT _ (TS _ 55)            }
  'language'      { PT _ (TS _ 56)            }
  'let'           { PT _ (TS _ 57)            }
  'letrec'        { PT _ (TS _ 58)            }
  'match'         { PT _ (TS _ 59)            }
  'new'           { PT _ (TS _ 60)            }
  'not'           { PT _ (TS _ 61)            }
  'or'            { PT _ (TS _ 62)            }
  'panic!'        { PT _ (TS _ 63)            }
  'return'        { PT _ (TS _ 64)            }
  'succ'          { PT _ (TS _ 65)            }
  'then'          { PT _ (TS _ 66)            }
  'throw'         { PT _ (TS _ 67)            }
  'throws'        { PT _ (TS _ 68)            }
  'true'          { PT _ (TS _ 69)            }
  'try'           { PT _ (TS _ 70)            }
  'type'          { PT _ (TS _ 71)            }
  'unfold'        { PT _ (TS _ 72)            }
  'unit'          { PT _ (TS _ 73)            }
  'variant'       { PT _ (TS _ 74)            }
  'with'          { PT _ (TS _ 75)            }
  '{'             { PT _ (TS _ 76)            }
  '|'             { PT _ (TS _ 77)            }
  '|>'            { PT _ (TS _ 78)            }
  '}'             { PT _ (TS _ 79)            }
  'Âµ'             { PT _ (TS _ 80)            }
  L_integ         { PT _ (TI $$)              }
  L_StellaIdent   { PT _ (T_StellaIdent $$)   }
  L_ExtensionName { PT _ (T_ExtensionName $$) }
  L_MemoryAddress { PT _ (T_MemoryAddress $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

StellaIdent :: { Gen.AbsSyntax.StellaIdent }
StellaIdent  : L_StellaIdent { Gen.AbsSyntax.StellaIdent $1 }

ExtensionName :: { Gen.AbsSyntax.ExtensionName }
ExtensionName  : L_ExtensionName { Gen.AbsSyntax.ExtensionName $1 }

MemoryAddress :: { Gen.AbsSyntax.MemoryAddress }
MemoryAddress  : L_MemoryAddress { Gen.AbsSyntax.MemoryAddress $1 }

Program :: { Gen.AbsSyntax.Program }
Program
  : LanguageDecl ListExtension ListDecl { Gen.AbsSyntax.AProgram $1 $2 $3 }

ListStellaIdent :: { [Gen.AbsSyntax.StellaIdent] }
ListStellaIdent
  : {- empty -} { [] }
  | StellaIdent { (:[]) $1 }
  | StellaIdent ',' ListStellaIdent { (:) $1 $3 }

LanguageDecl :: { Gen.AbsSyntax.LanguageDecl }
LanguageDecl : 'language' 'core' ';' { Gen.AbsSyntax.LanguageCore }

Extension :: { Gen.AbsSyntax.Extension }
Extension
  : 'extend' 'with' ListExtensionName { Gen.AbsSyntax.AnExtension $3 }

ListExtensionName :: { [Gen.AbsSyntax.ExtensionName] }
ListExtensionName
  : {- empty -} { [] }
  | ExtensionName { (:[]) $1 }
  | ExtensionName ',' ListExtensionName { (:) $1 $3 }

ListExtension :: { [Gen.AbsSyntax.Extension] }
ListExtension
  : {- empty -} { [] } | Extension ';' ListExtension { (:) $1 $3 }

Decl :: { Gen.AbsSyntax.Decl }
Decl
  : ListAnnotation 'fn' StellaIdent '(' ListParamDecl ')' ReturnType ThrowType '{' ListDecl 'return' Expr '}' { Gen.AbsSyntax.DeclFun $1 $3 $5 $7 $8 $10 $12 }
  | ListAnnotation 'generic' 'fn' StellaIdent '[' ListStellaIdent ']' '(' ListParamDecl ')' ReturnType ThrowType '{' ListDecl 'return' Expr '}' { Gen.AbsSyntax.DeclFunGeneric $1 $4 $6 $9 $11 $12 $14 $16 }
  | 'type' StellaIdent '=' Type { Gen.AbsSyntax.DeclTypeAlias $2 $4 }
  | 'exception' 'type' '=' Type { Gen.AbsSyntax.DeclExceptionType $4 }
  | 'exception' 'variant' StellaIdent ':' Type { Gen.AbsSyntax.DeclExceptionVariant $3 $5 }

ListDecl :: { [Gen.AbsSyntax.Decl] }
ListDecl : {- empty -} { [] } | Decl ListDecl { (:) $1 $2 }

LocalDecl :: { Gen.AbsSyntax.LocalDecl }
LocalDecl : Decl { Gen.AbsSyntax.ALocalDecl $1 }

ListLocalDecl :: { [Gen.AbsSyntax.LocalDecl] }
ListLocalDecl
  : {- empty -} { [] } | LocalDecl ';' ListLocalDecl { (:) $1 $3 }

Annotation :: { Gen.AbsSyntax.Annotation }
Annotation : 'inline' { Gen.AbsSyntax.InlineAnnotation }

ListAnnotation :: { [Gen.AbsSyntax.Annotation] }
ListAnnotation
  : {- empty -} { [] } | Annotation ListAnnotation { (:) $1 $2 }

ParamDecl :: { Gen.AbsSyntax.ParamDecl }
ParamDecl : StellaIdent ':' Type { Gen.AbsSyntax.AParamDecl $1 $3 }

ListParamDecl :: { [Gen.AbsSyntax.ParamDecl] }
ListParamDecl
  : {- empty -} { [] }
  | ParamDecl { (:[]) $1 }
  | ParamDecl ',' ListParamDecl { (:) $1 $3 }

ReturnType :: { Gen.AbsSyntax.ReturnType }
ReturnType
  : {- empty -} { Gen.AbsSyntax.NoReturnType }
  | '->' Type { Gen.AbsSyntax.SomeReturnType $2 }

ThrowType :: { Gen.AbsSyntax.ThrowType }
ThrowType
  : {- empty -} { Gen.AbsSyntax.NoThrowType }
  | 'throws' ListType9 { Gen.AbsSyntax.SomeThrowType $2 }

Type9 :: { Gen.AbsSyntax.Type }
Type9 : Type { $1 }

ListType9 :: { [Gen.AbsSyntax.Type] }
ListType9 : Type9 { (:[]) $1 } | Type9 ',' ListType9 { (:) $1 $3 }

MatchCase :: { Gen.AbsSyntax.MatchCase }
MatchCase : Pattern '=>' Expr { Gen.AbsSyntax.AMatchCase $1 $3 }

ListMatchCase :: { [Gen.AbsSyntax.MatchCase] }
ListMatchCase
  : {- empty -} { [] }
  | MatchCase { (:[]) $1 }
  | MatchCase '|' ListMatchCase { (:) $1 $3 }

OptionalTyping :: { Gen.AbsSyntax.OptionalTyping }
OptionalTyping
  : {- empty -} { Gen.AbsSyntax.NoTyping }
  | ':' Type { Gen.AbsSyntax.SomeTyping $2 }

PatternData :: { Gen.AbsSyntax.PatternData }
PatternData
  : {- empty -} { Gen.AbsSyntax.NoPatternData }
  | '=' Pattern { Gen.AbsSyntax.SomePatternData $2 }

ExprData :: { Gen.AbsSyntax.ExprData }
ExprData
  : {- empty -} { Gen.AbsSyntax.NoExprData }
  | '=' Expr { Gen.AbsSyntax.SomeExprData $2 }

Pattern :: { Gen.AbsSyntax.Pattern }
Pattern
  : Pattern 'as' Type { Gen.AbsSyntax.PatternAsc $1 $3 }
  | '<|' StellaIdent PatternData '|>' { Gen.AbsSyntax.PatternVariant $2 $3 }
  | 'inl' '(' Pattern ')' { Gen.AbsSyntax.PatternInl $3 }
  | 'inr' '(' Pattern ')' { Gen.AbsSyntax.PatternInr $3 }
  | '{' ListPattern '}' { Gen.AbsSyntax.PatternTuple $2 }
  | '{' ListLabelledPattern '}' { Gen.AbsSyntax.PatternRecord $2 }
  | '[' ListPattern ']' { Gen.AbsSyntax.PatternList $2 }
  | 'cons' '(' Pattern ',' Pattern ')' { Gen.AbsSyntax.PatternCons $3 $5 }
  | '(' Pattern ',' Pattern ')' { Gen.AbsSyntax.patternCons $2 $4 }
  | 'false' { Gen.AbsSyntax.PatternFalse }
  | 'true' { Gen.AbsSyntax.PatternTrue }
  | 'unit' { Gen.AbsSyntax.PatternUnit }
  | Integer { Gen.AbsSyntax.PatternInt $1 }
  | 'succ' '(' Pattern ')' { Gen.AbsSyntax.PatternSucc $3 }
  | StellaIdent { Gen.AbsSyntax.PatternVar $1 }
  | '(' Pattern ')' { $2 }

ListPattern :: { [Gen.AbsSyntax.Pattern] }
ListPattern
  : {- empty -} { [] }
  | Pattern { (:[]) $1 }
  | Pattern ',' ListPattern { (:) $1 $3 }

LabelledPattern :: { Gen.AbsSyntax.LabelledPattern }
LabelledPattern
  : StellaIdent '=' Pattern { Gen.AbsSyntax.ALabelledPattern $1 $3 }

ListLabelledPattern :: { [Gen.AbsSyntax.LabelledPattern] }
ListLabelledPattern
  : LabelledPattern { (:[]) $1 }
  | LabelledPattern ',' ListLabelledPattern { (:) $1 $3 }

Binding :: { Gen.AbsSyntax.Binding }
Binding : StellaIdent '=' Expr { Gen.AbsSyntax.ABinding $1 $3 }

ListBinding :: { [Gen.AbsSyntax.Binding] }
ListBinding
  : Binding { (:[]) $1 } | Binding ',' ListBinding { (:) $1 $3 }

Expr :: { Gen.AbsSyntax.Expr }
Expr
  : Expr1 ';' Expr { Gen.AbsSyntax.Sequence $1 $3 }
  | Expr1 ';' { $1 }
  | 'let' ListPatternBinding 'in' Expr { Gen.AbsSyntax.Let $2 $4 }
  | 'letrec' ListPatternBinding 'in' Expr { Gen.AbsSyntax.LetRec $2 $4 }
  | 'generic' '[' ListStellaIdent ']' Expr { Gen.AbsSyntax.TypeAbstraction $3 $5 }
  | Expr1 { $1 }

ListExpr :: { [Gen.AbsSyntax.Expr] }
ListExpr
  : {- empty -} { [] }
  | Expr { (:[]) $1 }
  | Expr ',' ListExpr { (:) $1 $3 }

Expr1 :: { Gen.AbsSyntax.Expr }
Expr1
  : Expr2 ':=' Expr1 { Gen.AbsSyntax.Assign $1 $3 }
  | 'if' Expr1 'then' Expr1 'else' Expr1 { Gen.AbsSyntax.If $2 $4 $6 }
  | Expr2 { $1 }

PatternBinding :: { Gen.AbsSyntax.PatternBinding }
PatternBinding
  : Pattern '=' Expr { Gen.AbsSyntax.APatternBinding $1 $3 }

ListPatternBinding :: { [Gen.AbsSyntax.PatternBinding] }
ListPatternBinding
  : PatternBinding { (:[]) $1 }
  | PatternBinding ',' ListPatternBinding { (:) $1 $3 }

Expr2 :: { Gen.AbsSyntax.Expr }
Expr2
  : Expr3 '<' Expr3 { Gen.AbsSyntax.LessThan $1 $3 }
  | Expr3 '<=' Expr3 { Gen.AbsSyntax.LessThanOrEqual $1 $3 }
  | Expr3 '>' Expr3 { Gen.AbsSyntax.GreaterThan $1 $3 }
  | Expr3 '>=' Expr3 { Gen.AbsSyntax.GreaterThanOrEqual $1 $3 }
  | Expr3 '==' Expr3 { Gen.AbsSyntax.Equal $1 $3 }
  | Expr3 '!=' Expr3 { Gen.AbsSyntax.NotEqual $1 $3 }
  | Expr3 { $1 }

ListExpr2 :: { [Gen.AbsSyntax.Expr] }
ListExpr2
  : Expr2 ';' { (:[]) $1 } | Expr2 ';' ListExpr2 { (:) $1 $3 }

Expr3 :: { Gen.AbsSyntax.Expr }
Expr3
  : Expr3 'as' Type2 { Gen.AbsSyntax.TypeAsc $1 $3 }
  | Expr3 'cast' 'as' Type2 { Gen.AbsSyntax.TypeCast $1 $4 }
  | 'fn' '(' ListParamDecl ')' '{' 'return' Expr '}' { Gen.AbsSyntax.Abstraction $3 $7 }
  | '<|' StellaIdent ExprData '|>' { Gen.AbsSyntax.Variant $2 $3 }
  | 'match' Expr2 '{' ListMatchCase '}' { Gen.AbsSyntax.Match $2 $4 }
  | '[' ListExpr ']' { Gen.AbsSyntax.List $2 }
  | Expr3 '+' Expr4 { Gen.AbsSyntax.Add $1 $3 }
  | Expr3 '-' Expr4 { Gen.AbsSyntax.Subtract $1 $3 }
  | Expr3 'or' Expr4 { Gen.AbsSyntax.LogicOr $1 $3 }
  | Expr4 { $1 }

Expr4 :: { Gen.AbsSyntax.Expr }
Expr4
  : Expr4 '*' Expr5 { Gen.AbsSyntax.Multiply $1 $3 }
  | Expr4 '/' Expr5 { Gen.AbsSyntax.Divide $1 $3 }
  | Expr4 'and' Expr5 { Gen.AbsSyntax.LogicAnd $1 $3 }
  | Expr5 { $1 }

Expr5 :: { Gen.AbsSyntax.Expr }
Expr5
  : 'new' '(' Expr5 ')' { Gen.AbsSyntax.Ref $3 }
  | '*' Expr5 { Gen.AbsSyntax.Deref $2 }
  | Expr6 { $1 }

Expr6 :: { Gen.AbsSyntax.Expr }
Expr6
  : Expr6 '(' ListExpr ')' { Gen.AbsSyntax.Application $1 $3 }
  | Expr6 '[' ListType ']' { Gen.AbsSyntax.TypeApplication $1 $3 }
  | Expr6 '.' StellaIdent { Gen.AbsSyntax.DotRecord $1 $3 }
  | Expr6 '.' Integer { Gen.AbsSyntax.DotTuple $1 $3 }
  | '{' ListExpr '}' { Gen.AbsSyntax.Tuple $2 }
  | '{' ListBinding '}' { Gen.AbsSyntax.Record $2 }
  | 'cons' '(' Expr ',' Expr ')' { Gen.AbsSyntax.ConsList $3 $5 }
  | 'List::head' '(' Expr ')' { Gen.AbsSyntax.Head $3 }
  | 'List::isempty' '(' Expr ')' { Gen.AbsSyntax.IsEmpty $3 }
  | 'List::tail' '(' Expr ')' { Gen.AbsSyntax.Tail $3 }
  | 'panic!' { Gen.AbsSyntax.Panic }
  | 'throw' '(' Expr ')' { Gen.AbsSyntax.Throw $3 }
  | 'try' '{' Expr '}' 'catch' '{' Pattern '=>' Expr '}' { Gen.AbsSyntax.TryCatch $3 $7 $9 }
  | 'try' '{' Expr '}' 'with' '{' Expr '}' { Gen.AbsSyntax.TryWith $3 $7 }
  | 'inl' '(' Expr ')' { Gen.AbsSyntax.Inl $3 }
  | 'inr' '(' Expr ')' { Gen.AbsSyntax.Inr $3 }
  | 'succ' '(' Expr ')' { Gen.AbsSyntax.Succ $3 }
  | 'not' '(' Expr ')' { Gen.AbsSyntax.LogicNot $3 }
  | 'Nat::pred' '(' Expr ')' { Gen.AbsSyntax.Pred $3 }
  | 'Nat::iszero' '(' Expr ')' { Gen.AbsSyntax.IsZero $3 }
  | 'fix' '(' Expr ')' { Gen.AbsSyntax.Fix $3 }
  | 'Nat::rec' '(' Expr ',' Expr ',' Expr ')' { Gen.AbsSyntax.NatRec $3 $5 $7 }
  | 'fold' '[' Type ']' Expr7 { Gen.AbsSyntax.Fold $3 $5 }
  | 'unfold' '[' Type ']' Expr7 { Gen.AbsSyntax.Unfold $3 $5 }
  | Expr7 { $1 }

Expr7 :: { Gen.AbsSyntax.Expr }
Expr7
  : 'true' { Gen.AbsSyntax.ConstTrue }
  | 'false' { Gen.AbsSyntax.ConstFalse }
  | 'unit' { Gen.AbsSyntax.ConstUnit }
  | Integer { Gen.AbsSyntax.ConstInt $1 }
  | MemoryAddress { Gen.AbsSyntax.ConstMemory $1 }
  | StellaIdent { Gen.AbsSyntax.Var $1 }
  | '(' Expr ')' { $2 }

Type :: { Gen.AbsSyntax.Type }
Type
  : 'fn' '(' ListType ')' '->' Type { Gen.AbsSyntax.TypeFun $3 $6 }
  | 'forall' ListStellaIdent '.' Type { Gen.AbsSyntax.TypeForAll $2 $4 }
  | 'Âµ' StellaIdent '.' Type { Gen.AbsSyntax.TypeRec $2 $4 }
  | Type1 { $1 }

Type1 :: { Gen.AbsSyntax.Type }
Type1
  : Type2 '+' Type2 { Gen.AbsSyntax.TypeSum $1 $3 } | Type2 { $1 }

Type2 :: { Gen.AbsSyntax.Type }
Type2
  : '{' ListType '}' { Gen.AbsSyntax.TypeTuple $2 }
  | '{' ListRecordFieldType '}' { Gen.AbsSyntax.TypeRecord $2 }
  | '<|' ListVariantFieldType '|>' { Gen.AbsSyntax.TypeVariant $2 }
  | '[' Type ']' { Gen.AbsSyntax.TypeList $2 }
  | Type3 { $1 }

Type3 :: { Gen.AbsSyntax.Type }
Type3
  : 'Bool' { Gen.AbsSyntax.TypeBool }
  | 'Nat' { Gen.AbsSyntax.TypeNat }
  | 'Unit' { Gen.AbsSyntax.TypeUnit }
  | 'Top' { Gen.AbsSyntax.TypeTop }
  | 'Bot' { Gen.AbsSyntax.TypeBottom }
  | '&' Type2 { Gen.AbsSyntax.TypeRef $2 }
  | StellaIdent { Gen.AbsSyntax.TypeVar $1 }
  | '(' Type ')' { $2 }

ListType :: { [Gen.AbsSyntax.Type] }
ListType
  : {- empty -} { [] }
  | Type { (:[]) $1 }
  | Type ',' ListType { (:) $1 $3 }

VariantFieldType :: { Gen.AbsSyntax.VariantFieldType }
VariantFieldType
  : StellaIdent OptionalTyping { Gen.AbsSyntax.AVariantFieldType $1 $2 }

ListVariantFieldType :: { [Gen.AbsSyntax.VariantFieldType] }
ListVariantFieldType
  : {- empty -} { [] }
  | VariantFieldType { (:[]) $1 }
  | VariantFieldType ',' ListVariantFieldType { (:) $1 $3 }

RecordFieldType :: { Gen.AbsSyntax.RecordFieldType }
RecordFieldType
  : StellaIdent ':' Type { Gen.AbsSyntax.ARecordFieldType $1 $3 }

ListRecordFieldType :: { [Gen.AbsSyntax.RecordFieldType] }
ListRecordFieldType
  : RecordFieldType { (:[]) $1 }
  | RecordFieldType ',' ListRecordFieldType { (:) $1 $3 }

Typing :: { Gen.AbsSyntax.Typing }
Typing : Expr ':' Type { Gen.AbsSyntax.ATyping $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

