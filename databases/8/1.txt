!!!!!! Students

-- есть по умолчанию
-- ДЗ-5.1.1
-- ДЗ-5.2.1
-- ДЗ-6.1.3
-- еще его можно было бы переделать в btree и сделать
-- покрывающим для всяких 5.1.2
create unique index StudentIdIdx on Students using hash (StudentId);

-- ДЗ-5.1.2
-- ДЗ-5.2.2
-- ДЗ-5.6.1
-- btree наверное лучше работает со строками благодаря префиксам?..
-- индексы на строки спорные....
-- хотя для обычных типов данных при проверке на = хэш лучше
-- еще если в btree добавить StudentId можно сделать unique
create index StudentNameIdx on Students using btree (StudentName);

-- нет смысла сортировать GroupId, наверное (хотя если они изначально
-- повторяют какую-то логику, что какой-то разряд это год,
-- то, может быть, btree лучше для каких-то запросов
-- ускоряет nj с планом, особенно отфильтрованным
-- ДЗ-5.5.1
-- ДЗ-5.5.2
-- ДЗ-5.5.3
create index StudentGroupToId on Students using hash (GroupId);

-- покрывающий для поиска студента по группе
-- полезно когда хотим достать из плана
-- или сгруппировать по группе
-- ДЗ-5.8.3
-- ДЗ-5.9.3
-- ДЗ-6.5.1
create unique index StudentsGidToSid on Students using btree (GroupId, StudentId)

-- ДЗ-7.2.2
create unique index StudentIdAndGroupToRecord on Students using hash (StudentId, GroupId)

!!!!!! Groups

-- должен быть по дефолту т.к. у групп Name -> Id
-- если мы не должны делать unique констрейнт, то можно было бы сделать покрывающим (добавить GroupId)
-- ДЗ-6.1.2
-- ДЗ-7.1.2
-- ДЗ-7.2.4
create unique index GroupNameToId on Groups using btree (GroupName);

-- создается по умолчанию
-- и ускоряет поиск имени группы по id
-- (+ добавляет констрейнт)
-- ДЗ-5.2.1
-- ДЗ-5.2.2
-- ДЗ-5.7.2
create unique index GroupId on Groups using hash (GroupId);


!!!!!! Courses

-- ДЗ-5.3.2
-- ДЗ-5.4.1
-- ДЗ-5.4.2
create unique index CourseNameToId on Courses using btree (CourseName, CourseId);

-- создается автоматически
-- ДЗ-5.5.1
-- ДЗ-5.5.2
-- ДЗ-5.5.3
create unique index CoursesIdUniq on Courses using hash (CourseId);

!!!!!! Lecturers

-- создается по умолчанию
-- не было запросов требующих LecturerName => вообще говоря не нужен
-- только для unique(PK)
create unique index LecturerIdUniq on Lecturers using hash (LecturerId);

-- ДЗ-5.3.4
-- ДЗ-5.3.6
-- ДЗ-5.6.1
create unique index LecturerNameToId on Lecturers using btree (LecturerName, LecturerId);

!!!!!! Plan

-- ДЗ-5.3.3
-- ДЗ-5.3.5
-- ДЗ-5.3.6
create index LecturerIdToPlan on Plan using hash (LecturerId);

-- по идее unique но в тестах было не так
-- нужен для проверки существования (корел.)
-- ДЗ-6.3.2
-- ДЗ-6.4.1
-- ДЗ-6.4.2
create index GiCiExistsInPlan on Plan using hash (GroupId, CourseId);


-- такой же по GroupId кажется не очень нужным,
-- он бы использовался в nj со Students, но кажется
--   лучше вычислять сначала в плане а потом вставлять студентов
--   с группой, потому что их больше
--   либо все равно full table scan
--   но любой hash можно переделать в btree
--   и добавить поле чтобы не лезь в таблицу
-- ДЗ-5.4.2
-- ДЗ-6.2.4
-- ДЗ-6.2.5
create index CourseIdToPlan on Plan using hash (CourseId);

!!!!!! Marks

-- ДЗ-5.3.1
-- ДЗ-6.1.3
-- ДЗ-6.1.4
-- hash потому что нет смысла искать по курсам, а оценок мало (5)
create index MarkCourseToStudent on Marks using hash (CourseId, Mark);

-- проверка того что у студента есть
-- какая-то оценка (или их количество)
-- ДЗ-7.1.3
-- ДЗ-7.1.4
-- ДЗ-7.1.5
create index MarkByStudentIdExists on Marks using hash (StudentId);

-- unique, но в тестах не так
-- проверяет наличие оценок при изветном StudentId, CourseId
-- полезен для проверки существования
-- ДЗ-6.4.1
-- ДЗ-6.4.2
-- ДЗ-6.4.3
create index SiCiInMarks on Marks using btree (StudentId, CourseId, Mark)

-- подмножество того что выше
-- ДЗ-5.8.1
-- ДЗ-5.9.1
-- ДЗ-5.8.2
create index SiAndMark on Marks using btree (StudentId, Mark)