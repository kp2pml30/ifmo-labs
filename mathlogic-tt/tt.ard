-- any predicate satisfies => =
\func Leibniz {A : \Type} {a a' : A}
              (f : \Pi (P : A -> \Type) -> \Sigma (P a -> P a') (P a' -> P a)) : a = a'
  => (f (\lam x => a = x)).1 idp

-- transport to rightmost
\func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a'
  => coe (\lam i => B (p @ i)) b right

-- = => f =
\func pmap {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' =>
  transport (\lam x => f a = f x) p idp

-- flip =
\func inv {A : \Type} {a a' : A} (p : a = a') : a' = a =>
  transport (\lam x => x = a) p (idp {A} {a})

-- = transitivity
\func transitivity {A : \Type} {a b c : A} (f1 : a = b) (f2 : b = c) : a = c =>
  transport (\lam a' => a = a') f2 f1

\data Empty
\func Not (A : \Type) : \Type => A -> Empty

\func task1 (A B : \Type) (p : A = B) (x : A) : B => coe (p @) x right

-- 0 *
\func zeroTimes (y : Nat) : 0 Nat.* y = 0
\elim y
  | 0 => idp
  -- 0 Nat.* (suc x) = 0 * Nat.* x + 0
  | suc x => pmap (Nat.+ 0) (zeroTimes x)

\func plusCommute (x y : Nat) : x Nat.+ y = y Nat.+ x
\elim x
  | 0 => idp
  -- x+y = x-1 + y+1
  | suc z => pmap suc (plusCommute z y)

\func plusAssoc (x y z : Nat) : x Nat.+ y Nat.+ z = x Nat.+ (y Nat.+ z)
\elim x
  | 0 => idp
  -- x+y + z = x-1 + y+z + 1 = x-1 + y + z+1
  | suc x' => pmap suc (plusAssoc x' y z)

\func timesFlipRule (x y : Nat) : (suc x) Nat.* y = y Nat.+ x Nat.* y
\elim y
  | 0 => idp
  | suc z =>
    -- suc x * z + suc x = z + (x * z + suc x)
    -- suc x * suc z = z + (x * suc z)
    transitivity
      -- suc x * z + suc x = z + x * z + suc x
      (pmap (Nat.`+` suc x) (timesFlipRule x z))
      -- suc ((z + x * z) + x) = suc (z + (x * z + x))
      -- z + x * z + suc x = z + (x * z + suc x)
      (pmap suc (plusAssoc z (x Nat.* z) x))

\func task2 (x y : Nat) : x Nat.* y = y Nat.* x
\elim x
  | 0 => zeroTimes y
  | suc z =>
    -- suc z * y = y * z + y
    -- suc z * y = y * suc z
    transitivity
      -- suc z * y = y + z * y
      (timesFlipRule z y)
      -- y + z * y = y * z + y
      (transitivity
        -- y + z * y = z * y + y
        (plusCommute y (z Nat.* y))
        -- z * y + y = y * z + y
        (pmap (Nat.`+` y) (task2 z y)))

-- distrib
\func task3 (x : Nat) (y : Nat) (z : Nat) : x Nat.* (y Nat.+ z) = x Nat.* y Nat.+ x Nat.* z
  \elim z
    -- x * y + x * 0 = x * y + 0
    | 0 => idp
    -- x * y + x * suc w = x * y + x * w + x
    | suc w =>
      -- x * (y + suc w) = x * y + (x * suc w)
      inv
        -- x * y + (x * w + x) = x * (y + w) + x
        -- x * y + (x * suc w) = x * (y + suc w)
        (transitivity
          -- x * y + x * w + x = x * y + (x * w + x)
          -- x * y + (x * w + x) = x * y + x * w + x
          (inv (plusAssoc (x Nat.* y) (x Nat.* w) x))
          -- x * (y + w) = x * y + x * w
          -- x * y + x * w = x * (y + w)
          -- x * y + x * w + x = x * (y + w) + x
          (pmap (Nat.`+` x) (inv (task3 x y w))))


\func inj (A B : \Type) (f : A -> B) => \Pi (a b : A) (eq : f a = f b) -> a = b

\func task4a' (a b : Nat) (eq : suc a = suc b) : a = b
  => pmap pred eq

\func task4a : inj Nat Nat suc =>
  task4a'

\func task4bfunc
  {A B C D : \Type}
  (f : A -> C) (g : B -> D)
  (p : \Sigma A B) : \Sigma C D
  =>
    (f p.1, g p.2)

\func componentWise {A B : \Type} {p1 q1 : A} {p2 q2 : B} (f1 : p1 = q1) (f2 : p2 = q2) : (p1, p2) = (q1, q2)
  => path (\lam i => (f1 @ i, f2 @ i))

\func task4b'
  {A B C D : \Type}
  {f : A -> C} {g : B -> D}
  (ai : inj A C f) (bi : inj B D g)
  (p1 : \Sigma A B) (p2 : \Sigma A B)
  (eq : task4bfunc f g p1 = task4bfunc f g p2)
  : p1 = p2 =>
    componentWise (ai p1.1 p2.1 (pmap (\lam x => x.1) eq)) (bi p1.2 p2.2 (pmap (\lam x => x.2) eq))

\func task4b
  {A B C D : \Type}
  {f : A -> C} {g : B -> D}
  (ai : inj A C f) (bi : inj B D g)
  : inj (\Sigma A B) (\Sigma C D) (task4bfunc f g) =>
    task4b' {A} {B} {C} {D} {f} {g} ai bi

\func square (x : Nat) : Nat => x Nat.* x

--\func task4c' (a b : Nat) (eq : square a = square b) : a = b
--  => idp

--\func task4c : inj Nat Nat square =>
--  task4c'

\func task4dtypo {A B : \Type} (f : A -> B) (ai : inj A B f) (x y : A) (pf : Not (f x = f y)) : Not (x = y) =>
  \lam p => pf (pmap f p)

\func task4d {A B : \Type} (f : A -> B) (ai : inj A B f) {x y : A} (p : Not (x = y)) : Not (f x = f y) =>
  -- pf is f x = f y
  \lam pf => p (ai x y pf)

\func proof_ne (a : Nat) : \Type \elim a
  | 0 => 0 = 0
  | suc x => Empty

\func task5 {y : Nat} (x : 0 = suc y) : Empty => transport proof_ne {0} {suc y} x idp

\func pred (a : Nat) : Nat
  \elim a
    | 0 => 0
    | suc b => b

\func task6 {a : Nat} (b : Nat) (c : Nat) (p : a Nat.+ b = a Nat.+ c) : b = c
  \elim a
  | 0 => p
  | suc x => pmap pred (task6 {x} (suc b) (suc c) p)

\func task6Not {a : Nat} (b : Nat) (c : Nat) (p : a Nat.+ b = a Nat.+ c -> Empty) (none : b = c) : Empty
  => p (pmap (Nat.+ a) none)

\func times2 (x : Nat) : 2 Nat.* x = x Nat.+ x
  \elim x
    | 0 => idp
    | suc y => pmap (Nat.+ 2) (times2 y)

\func task7 {x : Nat} (p : x = 2 Nat.* x) : x = 0 =>
  -- x * x = 0
  inv
    -- from x + 0 = x + (x + x)
    -- 0 = x + x
    (task6 {x} 0 x
      -- x = x + x
      (transitivity
          -- x = 2 * x
          p
          -- 2 * x = x + x
          (times2 x)))

\func minus (a b : Nat) : Nat
  | a, 0 => a
  | 0, _ => 0
  | suc x, suc y => minus x y

\func minusZero {a : Nat} : minus a 0 = a
  \elim a
    | 0 => idp
    | suc w => idp

\func task10 (a b : Nat) : minus (a Nat.+ b) b = a
  \elim b
    | 0 => minusZero
    | suc x => task10 a x

\func pow2 (a : Nat) : Nat
  \elim a
    | 0 => 1
    | suc b => pow2 b Nat.* 2 -- Nat.+ pow2 b

\func task11 (a b : Nat) : pow2 (a Nat.+ b) = pow2 a Nat.* pow2 b
  \elim b
    | 0 => idp
    | suc c =>
      -- pow2 (a + c) * 2 = pow2 a * (pow2 c + pow2 c)
      -- pow2 (a + c) * 2 = pow2 a * pow2 (suc c)
      transitivity
        -- pow2 (a + c) * 2 = pow2 a * pow2 c * 2
        (pmap (Nat.`*` 2) (task11 a c))
        -- pow2 a * (pow2 c + pow2 c) = pow2 a * pow2 c + pow2 a * pow2 c
        -- pow2 a * pow2 c + pow2 a * pow2 c = pow2 a * (pow2 c + pow2 c)
        -- pow2 a * pow2 c * 2 = pow2 a * (pow2 c + pow2 c)
        (inv (task3 (pow2 a) (pow2 c) (pow2 c)))