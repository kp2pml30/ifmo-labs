-- see  DOI:10.1007/3-540-45627-9_23

MODULE main
VAR
	t_0 : process lamp (0, n, states, entering, nums, x_big, cur_xs);
	t_1 : process lamp (1, n, states, entering, nums, x_big, cur_xs);
	states : array 0 .. n - 1 of {UNLOCKED, SET_ENTER, CALC_MAX, CALC_MAX_NEXT, PRE_WAIT, WAIT_1, WAIT_2, WAIT_NEXT, RESET_X, CS, UNLOCKING};
	entering : array 0 .. n - 1 of boolean;
	nums : array 0 .. n - 1 of -1..2*n;
	x_big : array 0..0 of 0..2*n;
	cur_xs : array 0..n - 1 of 0 .. 2*n;
ASSIGN
	init(x_big[0]) := 0;
DEFINE
	n := 2;

LTLSPEC
	G(!(states[0] = CS & states[1] = CS));

MODULE lamp (i, n, states, entering, nums, x_big, cur_xs)
DEFINE
	state := states[i];
	cur_x := cur_xs[i];
	modulo := 2 * n - 1;
VAR
	cur_max : -1..2*n;
	cur_index : 0..n+1;
JUSTICE running;
-- JUSTICE TRUE;
COMPASSION (state = CS, state = UNLOCKING);
ASSIGN
	init(states[i]) := UNLOCKED;
	init(entering[i]) := FALSE;
	init(nums[i]) := -1;
	init(cur_xs[i]) := 0;
	init(cur_index) := 0;
	init(cur_max) := -1;
	next(states[i]) := case
		state = UNLOCKED : {UNLOCKED, SET_ENTER};
		state = SET_ENTER : CALC_MAX;
		state = CALC_MAX & cur_index = n : PRE_WAIT;
		state = CALC_MAX & cur_index < n : CALC_MAX_NEXT;
		state = CALC_MAX_NEXT : CALC_MAX;
		state = PRE_WAIT : WAIT_1;
		state = WAIT_1 & cur_index = n : RESET_X;
		state = WAIT_1 & cur_index < n & cur_index = i : WAIT_NEXT;
		state = WAIT_1 & cur_index < n & cur_index != i & !entering[cur_index] : WAIT_2;
		state = WAIT_1 : WAIT_1;
		state = WAIT_2 &
			cur_index < n &
			cur_index != i &
			(nums[cur_index] = -1 |
				(nums[i] + n - 1 - nums[i]) mod modulo < (nums[cur_index] + n - 1 - nums[i]) mod modulo |
				(nums[i] + n - 1 - nums[i]) mod modulo = (nums[cur_index] + n - 1 - nums[i]) mod modulo & i < cur_index)
			: WAIT_NEXT;
		state = WAIT_2 : WAIT_2;
		state = WAIT_NEXT : WAIT_1;
		state = RESET_X : CS;
		state = CS : {CS, UNLOCKING};
		state = UNLOCKING : UNLOCKED;
		TRUE : state;
	esac;
	next(entering[i]) := case
		state = SET_ENTER : TRUE;
		state = PRE_WAIT : FALSE;
		TRUE : entering[i];
	esac;
	next(cur_xs[i]) := case
		state = SET_ENTER : x_big[0];
		TRUE : cur_x;
	esac;
	next(nums[i]) := case
		state = PRE_WAIT : ((cur_max - n + 1 + cur_x + 1) mod modulo + modulo) mod modulo;
		state = UNLOCKING : -1;
		TRUE : nums[i];
	esac;
	next(cur_max) := case
		state = SET_ENTER : ((x_big[0] + n - 1 - x_big[0]) mod modulo + modulo) mod modulo;
		state = UNLOCKING : -1;
		state = CALC_MAX & cur_index < n & nums[cur_index] != -1 : max(cur_max, ((nums[cur_index] + n - 1 - cur_x) mod modulo + modulo) mod modulo);
		TRUE : cur_max;
	esac;
	next(x_big[0]) := case
		state = RESET_X : cur_x;
		TRUE : x_big[0];
	esac;
	next(cur_index) := case
		state = SET_ENTER : 0;
		state = CALC_MAX_NEXT & cur_index < n : cur_index + 1;
		state = WAIT_NEXT & cur_index < n : cur_index + 1;
		state = PRE_WAIT : 0;
		state = RESET_X : 0;
		TRUE : cur_index;
	esac;

LTLSPEC
	-- G(state = SET_ENTER -> !(G state != CS));
	G(state = SET_ENTER -> F state = CS);
