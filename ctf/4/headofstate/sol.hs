{-# LANGUAGE BangPatterns #-}

import Data.Char
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Foldable
import Data.Maybe

makeMultimap :: Ord k => [(k ,v)] -> Map.Map k [v]
makeMultimap = foldl'
	(flip $ \(k, v) -> Map.insertWith (++) k [v])
	Map.empty

sols = makeMultimap $ map (\(f, c, t) -> (f, (t, chr c)))
	[ (1, 0x6B, 2)
	, (1, 0x68, 6)
	, (2, 0x6F, 3)
	, (2, 0x73, 7)
	, (3, 0x68, 2)
	, (3, 0x75, 7)
	, (4, 0x70, 3)
	, (4, 0x69, 5)
	, (4, 0x67, 0x0B)
	, (4, 0, 0)
	, (5, 0x61, 1)
	, (5, 0x66, 4)
	, (5, 0x6D, 6)
	, (5, 0, 0)
	, (6, 0x6F, 7)
	, (6, 0, 0)
	, (7, 0x6A, 8)
	, (7, 0, 0)
	, (8, 0x79, 5)
	, (8, 0x75, 7)
	, (8, 0, 0)
	, (0x0B, 0x65, 0x0C)
	, (0x0B, 0, 0)
	, (0x0C, 0x75, 0x0F)
	, (0x0D, 0x72, 0x0B)
	, (0x0D, 0x6B, 0x0C)
	, (0x0D, 0x6D, 0x0E)
	, (0x0D, 0x76, 0x13)
	, (0x0D, 0, 0)
	, (0x0E, 0x73, 0x0B)
	, (0x0F, 0x66, 0x0D)
	, (0x0F, 0x63, 0x0E)
	, (0x10, 0x7A, 0x11)
	, (0x10, 0x6C, 0x12)
	, (0x10, 0, 0)
	, (0x11, 0x70, 0x12)
	, (0x11, 0x61, 0x14)
	, (0x12, 0x66, 0x13)
	, (0x12, 0x68, 0x15)
	, (0x12, 0x6A, 0x18)
	, (0x12, 0, 0)
	, (0x13, 0x6F, 0x10)
	, (0x14, 0x6E, 0x12)
	, (0x14, 0x62, 0x15)
	, (0x15, 0x65, 0x13)
	, (0x16, 0x6D, 0x17)
	, (0x17, 0x71, 0x16)
	, (0x17, 0x6A, 0x1A)
	, (0x17, 0, 0)
	, (0x18, 0x65, 0x16)
	, (0x19, 0x77, 0x16)
	, (0x19, 0x6B, 0x18)
	, (0x19, 0x6E, 0x1A)
	, (0x19, 0x74, 0x65)
	, (0x1A, 0x72, 0x1B)
	, (0x1A, 0, 0)
	, (0x1B, 0x7A, 0x19)
	, (0x1B, 0x6F, 0x1A)
	, (0x65, 0x65, 0x68)
	, (0x65, 0x7A, 0x6A)
	, (0x65, 0x75, 0x6B)
	, (0x65, 0x6C, 0x6F)
	, (0x65, 0, 0)
	, (0x66, 0x64, 0x67)
	, (0x66, 0x7A, 0x539)
	, (0x66, 0, 0)
	, (0x67, 0x6C, 0x539)
	, (0x67, 0, 0)
	, (0x68, 0x6A, 0x69)
	, (0x68, 0, 0)
	, (0x69, 0x6E, 0x69)
	, (0x69, 0x68, 0x6B)
	, (0x69, 0x74, 0x6F)
	, (0x69, 0, 0)
	, (0x6A, 0x6F, 0x6B)
	, (0x6A, 0x78, 0x6C)
	, (0x6A, 0x6D, 0x6E)
	, (0x6A, 0, 0)
	, (0x6B, 0x72, 0x6F)
	, (0x6C, 0x67, 0x6D)
	, (0x6C, 0x62, 0x70)
	, (0x6D, 0x6F, 0x70)
	, (0x6E, 0x71, 0x70)
	, (0x6E, 0x78, 0x73)
	, (0x6E, 0x68, 0x78)
	, (0x6E, 0, 0)
	, (0x6F, 0x6B, 0x69)
	, (0x70, 0x6F, 0x75)
	, (0x71, 0x69, 0x77)
	, (0x71, 0x67, 0x78)
	, (0x72, 0x6E, 0x67)
	, (0x72, 0x79, 0x73)
	, (0x72, 0x65, 0x74)
	, (0x72, 0x70, 0x76)
	, (0x72, 0, 0)
	, (0x73, 0x6D, 0x74)
	, (0x73, 0x77, 0x76)
	, (0x74, 0x6E, 0x74)
	, (0x75, 0x6C, 0x6D)
	, (0x76, 0x71, 0x72)
	, (0x77, 0x64, 0x71)
	, (0x77, 0x69, 0x78)
	, (0x77, 0, 0)
	, (0x78, 0x69, 0x6B)
	, (0x78, 0x6B, 0x71)
	, (0x78, 0x73, 0x77)
	, (0x78, 0, 0)
	]

bfs :: [(Int, String)] -> Set.Set Int -> String
bfs cur visited
	| null cur = "<failed>"
	| isJust found1337 = snd $ fromJust found1337
	| otherwise =
		let
			ncur :: [(Int, String)]
			ncur = concatMap
				(\(i, s) -> map
					(\(toi, toc) -> (toi, toc:s))
					(getPaths $ sols Map.! i))
				cur in
		bfs ncur (Set.union visited $ Set.fromList $ map fst cur)
	where
		getPaths :: [(Int, Char)] -> [(Int, Char)]
		getPaths = filter (not . flip Set.member visited . fst)
		found1337 = find (\x -> fst x == 1337) cur

main = do
	print $ map fst $ Map.toList sols
	print $ concatMap (map fst . snd) $ Map.toList sols
	putStrLn $ bfs [(1, "")] Set.empty

-- gives us hojyfgeufvoljemjrztzmxwqnl