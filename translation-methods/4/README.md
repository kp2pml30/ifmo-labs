# Генератор LL(1) парсеров

## Синтезируемые аттрибуты
Реализован 1 аттрибут, чтобы сделать несколько, достаточно сделать `data` тип с полями, за счет ленивости они смогут зависить друг от друга

## Наследуемые аттрибуты
Для реализации наследуемых аттрибутов через синтезируемые нужна монада `Reader` (и метод `local` отправляющий в детей свой аттрибут)

## Оптимизация

Когда используется `FOLLOW`: всегда кроме случая когда все условие альтернативы зануляется.

Для LL(1) у нас не может быть несколько зануляемых альтернатив, значит FOLLOW нужен только для "обработки ошибок"

Рассмотрим построение `FIRST`:

```
for ( A -> a )
	FIRST[A] ∪= FIRST(a)
```

Таким образом мы в момент объединения знаем в какое правило нам идти, а значит уже в этот момент можно сохранить эту информацию и проверить что наша грамматика LL(1).
